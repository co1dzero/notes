# 公司

```apl
test 18500000001 111111aaWSX

dev
买家：15618334721
卖家：13975837847
卖家账号：  15274921111  111111aaWSX 
厂家：17788998206
密码：111111aaWSX
13573378822  111111aaWSX

厂家：18684705001     密码：111111aaWSX
买家：18500000001    密码：111111aaWSX
卖家：18670380849   111111aaWSX
```

https://test.greatgas.cn/new/

https://test.greatweb.cn/new/




```apl
工时：https://ep-project-personnel-management-front.ennew.com/

git：https://gitlab.enncloud.cn/
项目：greatgas-vue-lng-flagship（首页、舟山交易大厅）、greatgas-vue-base（管理系统）、greatgas-vue-deal（帮助中心）、greatgas-app-vue（移动端H5）
组件库：greatgas-vue-common

jenkins：http://10.23.166.10:8080/jenkins
环境：dev、test、fat
项目：gastrade（greatgas-vue-lng-flagship）、gasbase（greatgas-vue-base）、gasdeal（greatgas-vue-deal）、gasweb（greatgas-app-vue）

jira：https://jira.enncloud.cn/

私服：http://10.39.36.124:8080/nexus/repository/npm-public/

日报：https://docs.qq.com/sheet/DVU5Icm1vTUlJclNW

交易平台地址：https://${env}.greatgas.cn/
env：dev、test、fat、uat、www
测试账号：
买家：13975837847 111111aaWSX
买家：18500000001 111111aaWSX 18800003000 111111aaWSX
卖家：18684705001 111111aaWSX 17752870227
厂家：17788998206 111111aaWSX 18684705001
```



------

# 反复出现好气网循环登录

[JSESSIONID](https://blog.csdn.net/rqt1013_/article/details/125410725)

若好气网账号已登录，退出登录然后登录好气网

先去项目对应的地址登录，复制cookie里的JSESSIONID，覆盖config.js文件里的JSESSIONID，然后再访问对应路由就可以了

------

# npm 相关问题

## npm i 安装时-D 和 -S的区别是什么？

npm安装时-S -D的区别是什么？

> -S
> 即–save（保存）
> 包名会被注册在package.json的dependencies里面，在生产环境下这个包的依赖依然存在。
> 如安装lodash：

```js
npm i --save lodash
```

> -D
> 即–dev（开发）
> 包名会被注册在package.json的devDependencies里面，仅在开发环境下存在的包用-D，如babel，sass-loader这些解析器。

注意：在使用npm install一个插件的时候，需要添加上-s或-d，不然不会在package.json中显示插件名称及版本号。

------

## npm i安装依赖问题添加公司源

源http://10.39.36.124:8080/nexus/repository/npm-public/

> nrm 这个是包源管理的小工具
>
> npm i nrm -g
>
> nrm add local http://10.39.36.124:8080/nexus/repository/npm-public/
>
> nrm use local
>
> 再安装依赖包就好了

------

## 项目中新增的图片

> 大家以后在项目中新增的图片都使用 https://tinypng.com/ 压缩一下，原有的图片我会统一处理



------

## 安装组件库或安装依赖报错

[引用](https://blog.csdn.net/jolinoy/article/details/123948912)

报错信息：

```coffeescript
npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR! 
npm ERR! While resolving: test-first@0.1.0
npm ERR! Found: vue@2.7.14
npm ERR! node_modules/vue
npm ERR!   vue@"^2.6.14" from the root project
npm ERR! 
npm ERR! Could not resolve dependency:
npm ERR! peer vue@">=3.2.0" from ant-design-vue@3.2.15
npm ERR! node_modules/ant-design-vue
npm ERR!   ant-design-vue@"*" from the root project
npm ERR! 
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR!
npm ERR! See C:\Users\shizeyu\AppData\Local\npm-cache\eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\shizeyu\AppData\Local\npm-cache\_logs\2022-12-27T00_28_37_936Z-debug-0.log
```

输入npm -V发现我的npm版本为8.x的，因为npm7.x版本对某些命令比npm6.x更严格

<font color='red'>解决办法有两种：</font>
1.在命令后加上`--legacy-peer-deps`
2.使用npm6.x

> 提示：使用npm@6不需要[卸载npm](https://so.csdn.net/so/search?q=卸载npm&spm=1001.2101.3001.7020)@7。可以使用npx指定npm的版本。例如：`npx -p npm@6 npm i --legacy-peer-deps`

> 如果这不能立即起作用，可以先删除 `node_modules`和 `package-lock.json`

```
例如安装ant-design

npm install ant-design-vue --save基础上加上--legacy-peer-deps
npm install ant-design-vue --save --legacy-peer-deps
```









------



## 代码提交的注释规范

upd: 用于更新代码，fix: 用于修改bug，主要就是这俩

> features/
>
> hotfixes/

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\lQLPJx4_STDfZ4TNA1jNAyWw-1nyN3jD2u4DlDcY4cCMAA_805_856.png)

> <font color='gree'>UAT 是预发布环境，肯定用预发布分支 release-prod 噻</font>
>
> <font color='gree'>真正的 prod 是 main 分支</font>
>
> <font color='gree'>这个是生产环境的</font>

| 类型     | 描述             |
| -------- | ---------------- |
| feat     | 新功能           |
| upd      | 更新代码         |
| del      | 删除文件或者功能 |
| fix      | bug修改          |
| docs     | 文档修改         |
| style    | 样式修改         |
| refactor | 代码重构         |
| test     | 测试用例修改     |
| chore    | 其他修改         |
| revert   | 恢复上次提交     |

## 各种环境（dev、test、sit、uat、prod、pre、fat）

>dev（Development environment）：开发环境。用于开发者调试使用。
>
>test：测试环境。
>
>sit（System Integration Test）：系统集成测试。
>
>uat（User Acceptance environment）：用户验收测试环境。生产环境下的软件测试者测试使用。预发布环境。
>
>pre：灰度环境。灰度测试环境就是生产环境，生产数据，所影响的也是生产环境，只是范围比测试环境更广，更真实。其实就是小范围的生产环境。类似于游戏内测。
>
>fat（Feature Acceptance Test environment）：功能验收测试环境。软件测试者测试使用。
>
>prod（Production environment）：生产环境。正式线上环境。

## 尽量单个功能或单个 BUG 提交一次，如果是多个关联项一起修改，则写入多个 jira 单号

> 示例：git commit -m "feat: 增加样式编写和代码提交规范，ZNJY-1503、ZNJY-1505"







------

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-24_15-07-43.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-24_15-11-02.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-24_15-11-23.png)

目前计划下个版本在所有项目中引入 keep-alive 组件，通过配置路由 meta 的 keepAlive 属性来启用，keep-alive 组件使用 $route.fullPath 为 key，大家可以在跳转对应页面时加上时间戳来避免数据缓存引发的问题







------

# 模块

1. ## app 弹窗（取消原因单选）选中变蓝

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_16-33-54.jpg)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_16-34-23.jpg)

```vue
<template>
  <van-form ref="ruleForm" @submit="submitRejection" :show-error="false">
    <van-popup round v-model="show" closeable position="bottom" @close="cancel()">
      <div class="popup-box">
        <div class="title">取消订单</div>
        <div class="content">
          <van-field
            name="radio"
            label="取消原因"
            class="radio-style"
            required
            :rules="[{ required: true, message: '请选择取消原因' }]">
            <template #input>
              <van-radio-group v-model="radio" direction="horizontal">
                <van-button
                  native-type="button"
                  round
                  type="info"
                  class="button-style"
                  :class="{ 'button-style-active': radio === '01' }"
                  @click="getPay('01')"
                  >管容预约失败</van-button
                >
                <van-button
                  native-type="button"
                  round
                  type="info"
                  class="button-style"
                  :class="{ 'button-style-active': radio === '02' }"
                  @click="getPay('02')"
                  >管输费超标</van-button
                >
                <van-button
                  native-type="button"
                  round
                  type="info"
                  class="button-style"
                  :class="{ 'button-style-active': radio === '03' }"
                  @click="getPay('03')"
                  >其他</van-button
                >
              </van-radio-group>
            </template>
          </van-field>
          <van-field
            class="textarea"
            v-model="text"
            rows="1"
            :autosize="{ maxHeight: 100 }"
            label="说明"
            type="textarea"
            placeholder="请输入说明"
            maxlength="1024" />
          <van-field
            name="uploader"
            label="上传附件"
            class="uploader"
            input-align="right"
            :border="false">
            <template #input>
              <van-uploader
                accept=""
                :deletable="true"
                :show-upload="false"
                v-model="file"
                :after-read="afterRead"
                :before-read="beforeRead"
                :max-count="1"
                preview-size="50px"
                :max-size="10 * 1024 * 1024"
                @oversize="onOversize"
                :preview-image="false">
                <span style="color: #969799"
                  >添加附件<van-icon name="add-o" size="16" color="#0473FF" style="margin: 6px"
                /></span>
                <!-- <template #preview-cover>
                    <div class="preview-cover van-ellipsis">{{ extAddress }}</div>
                  </template> -->
              </van-uploader>
            </template>
          </van-field>
          <div class="annotation">支持pdf/jpg/jpeg/doc/docx格式，上限10MB</div>

          <div class="file-card" v-if="file.length !== 0">
            <div class="left-icon">
              <img
                width="38px"
                height="38px"
                src="@/assets/imager/PDF-icon.png"
                alt="mileage"
                v-if="fileImgSrc === '02'" />
              <img
                width="38px"
                height="38px"
                src="@/assets/imager/WORD-icon.png"
                alt="mileage"
                v-if="fileImgSrc === '01'" />
              <img
                width="38px"
                height="38px"
                :src="fileImgSrc"
                alt="mileage"
                v-if="fileImgSrc !== '01' && fileImgSrc !== '02'"
                @click="ImagePreview(fileImgSrc)" />
            </div>
            <div class="file-content">
              {{ fileName }}
              <br />
              <span style="font-size: 12px; color: #969799">{{ fileSize }}</span>
            </div>
            <div @click="file = []" class="right-icon">
              <img width="22px" height="22px" src="@/assets/imager/dele-icon.png" alt="mileage" />
            </div>
          </div>
          <div class="btn-box">
            <van-button round native-type="button" plain type="info" @click="cancel()"
              >取消</van-button
            >
            <van-button
              round
              native-type="button"
              type="info"
              :loading="loading3"
              @click="submitRejection()"
              >保存</van-button
            >
          </div>
        </div>
      </div>
    </van-popup>
  </van-form>
</template>

<script>
import { Card, Button, Dialog, Radio, Field, Uploader, Popup, ImagePreview } from 'vant';
import { deliveryUpload, pngBatchRejectAgree } from '@/http/app';
export default {
  name: 'bidd-order-detail',
  components: {
    [Card.name]: Card,
    [Button.name]: Button,
    [Dialog.name]: Dialog,
    [Radio.name]: Radio,
    [Field.name]: Field,
    [Uploader.name]: Uploader,
    [Popup.name]: Popup,
    [ImagePreview.name]: ImagePreview,
  },
  data() {
    return {
      loading3: false,
      show: false,
      radio: '',
      text: '',
      file: [],
      extAddress: '',
      filePostfix: '',
      agreeCancelReason: {},
    };
  },
  computed: {
    fileName() {
      return this.file?.[0].file.name;
    },
    fileSize() {
      const num = this.file?.[0].file.size;
      return num > 1024
        ? num / 1024 > 1024
          ? (num / 1024 / 1024).toFixed(2) + 'MB'
          : (num / 1024).toFixed(2) + 'KB'
        : num.toFixed(2) + 'B';
    },
    fileImgSrc() {
      const name = this.file?.[0].file.name;
      const name1 = name.substring(name.lastIndexOf('.') + 1);
      return name1 === 'jpg' || name1 === 'jpeg'
        ? this.file?.[0]?.content
        : name1 === 'doc' || name1 === 'docx'
        ? '01'
        : '02';
    },
  },
  watch: {
    file(e) {
      if (e?.length === 0) {
        this.extAddress = '';
        this.filePostfix = '';
      }
    },
  },
  methods: {
    async afterRead(file) {
      const param = new FormData();
      param.append('file', file.file);
      await deliveryUpload(param).then(res => {
        this.extAddress = `/new/fileInfo/img/${res.data.results.fileId}`;
        // 去除.上传保证后端判断生效
        this.filePostfix = res.data.results.filePostfix.substring(1);
      });
    },
    beforeRead(file) {
      if (
        file.type !== 'image/jpeg' &&
        file.type !== 'image/jpg' &&
        file.type !== 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' &&
        file.type !== 'application/msword' &&
        file.type !== 'application/pdf'
      ) {
        this.$notify({ type: 'warning', message: '只允许上传pdf/jpg/jpeg/doc/docx格式的图片' });
        return false;
      } else {
        return true;
      }
    },
    onOversize() {
      this.$notify({ type: 'warning', message: '文件大小不得超过10MB' });
    },
    cancel() {
      this.show = false;
      this.loading2 = false;
      this.radio = '';
      this.text = '';
      this.file = [];
      this.extAddress = '';
      this.filePostfix = '';
      this.$refs.ruleForm?.resetValidation();
    },
    submitRejection() {
      this.loading3 = true;
      this.$refs.ruleForm
        .validate(['radio'])
        .then(() => {
          console.log('校验通过');

          pngBatchRejectAgree({
            agreeId: this.agreeId,
            reasonCode: this.radio,
            description: this.text,
            filePostfix: this.filePostfix,
            extAddress: this.extAddress,
          })
            .then(e => {
              console.log(e);
              this.$notify({ type: 'success', message: '该订单已拒绝' });
              this.getDetail();
            })
            .finally(() => {
              this.loading3 = false;
              this.loading2 = false;
              this.show = false;
            });
        })
        .catch(err => {
          console.log('校验失败', err);
          this.loading3 = false;
        });
    },
    download() {
      // 特殊机型浏览器失效
      const str = this.$store.getters.location + this.agreeCancelReason.extAddress;
      const Str = str.replace('/img', '');
      const newStr = Str.replace('//new', '/new');
      const link = document.createElement('a');
      link.style.display = 'none';
      link.href = newStr;
      link.setAttribute('download', '取消原因.' + this.agreeCancelReason.filePostfix);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      window.ic.run({
        action: 'system.download',
        params: {
          fileUrl: newStr,
          fileName: '取消原因.' + this.agreeCancelReason.filePostfix,
        },
        success: res => {
          console.log(res);
        },
      });
    },
    getPay(item) {
      this.radio = item;
    },
    ImagePreview(image) {
      ImagePreview([image]);
    },
  },
};
</script>

<style lang="scss" scoped>
.popup-box {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #fff;

  .title {
    box-sizing: border-box;
    height: 60px;
    padding: 20px 0;
    font-size: 16px;
    font-weight: 700;
    text-align: center;
    background: #fff;
  }

  .content {
    background-color: #fff;

    .radio-style {
      display: block;

      ::v-deep .van-field__label {
        margin-bottom: 10px;
      }

      ::v-deep .button-style {
        height: 32px;
        margin-right: 10px;
        color: #565961;
        background: #f2f4f8 !important;
        border-color: #f2f4f8 !important;
        border-radius: 316px;
      }

      ::v-deep .button-style-active {
        color: #487aff;
        background: #e5f1ff !important;
        border-color: #e5f1ff !important;
      }
    }

    .textarea {
      display: block;

      ::v-deep .van-field__label {
        margin-bottom: 10px;
      }
    }

    .uploader {
      .preview-cover {
        position: absolute;
        bottom: 0;
        box-sizing: border-box;
        width: 100%;
        padding: 4px;
        font-size: 12px;
        color: #fff;
        text-align: center;
        background: rgb(0 0 0 / 30%);
      }
    }

    .annotation {
      margin-left: 16px;
      font-size: 14px;
      color: #969799;
    }

    .file-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 16px;
      margin: 20px 16px 0;
      background: #f2f4f8;
      border-radius: 8px;

      .file-content {
        width: 100%;
        margin: 0 12px;
        overflow: hidden;
        font-size: 16px;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .left-icon,
      .right-icon {
        display: flex;
        align-items: center;
      }
    }

    .btn-box {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      border-top: 1px solid #ebedf0;

      button {
        width: 50%;
        height: 40px;
        margin: 10px;
        font-size: 16px;
      }
    }

    ::v-deep .van-field__label {
      font-size: 16px;
      font-weight: 700;
      color: #1c1c1e;
    }
  }
}
</style>

```













------

# JS

## js下载文件

创建虚拟连接法：

这段代码是在通过JS实现下载文件的功能，具体实现方式如下：

1. 创建一个`a`标签元素，将其添加到页面中；
2. 设置`a`标签`href`属性为要下载文件的URL；
3. 设置`a`标签`download`属性为空字符串，表示使用原始文件名进行下载；
4. 将`a`标签元素的`display`属性设置为`none`，以隐藏它；
5. 触发`a`标签的点击事件，即可开始下载文件；
6. 下载完成后，将`a`标签从页面中移除。

具体代码如下：

```js
const link = document.createElement('a');
link.href = newStr; // newStr是处理过的下载链接
link.setAttribute('download', ''); // 设置download属性为空字符串，表示使用原始文件名进行下载
link.style.display = 'none'; // 隐藏a标签
document.body.appendChild(link); // 添加到页面中
link.click(); // 触发点击事件，开始下载
document.body.removeChild(link); // 下载完成后，将a标签从页面中移除
```

以上代码会将名为`file.jpg`的文件下载到本地，并使用原始文件名进行保存。如果想要指定新的文件名，可以将`download`属性设置为新的文件名即可。

------

## 建议：

大家开发的时候可以尽量使用新特性，像ES13中的 at 方法 [1, 2, 3].at(-1)，ES12中的逻辑赋值运算符 ||=、&&=、??=，ES11中的可选链接 user?.info?.name、空值合并 user.level ?? 'no level' 等等，这些我们的项目都支持使用

------

## 关于pdf文件预览及iframe

[vue中预览PDF文档](https://blog.csdn.net/qq_38543537/article/details/123715548)

[iframe在Vue中的应用](https://blog.csdn.net/weixin_42671417/article/details/105809529)



------

## css样式的书写顺序及原理

[引用](https://blog.csdn.net/qq_36060786/article/details/79311244)

（1）定位属性：position  display  float  left  top  right  bottom   overflow  clear   z-index

（2）自身属性：width  height  padding  border  margin   background

（3）文字样式：font-family   font-size   font-style   font-weight   font-varient   color   

（4）文本属性：text-align   vertical-align   text-wrap   text-transform   text-indent    text-decoration   letter-spacing    word-spacing    white-space   text-overflow

（5）css3中新增属性：content   box-shadow   border-radius  transform……

------

## stylelint 和 commitlint

> 电子沙盘相关项目已经加上 stylelint 和 commitlint 相关规范，提交代码时会运行 stylelint 和 eslint 检测，如果是 stylelint 的检测不通过需要单独运行 npm run stylelint 命令查看具体错误，代码提交格式请查看 commitlint.config.js 中的规范和示例，有问题及时沟通

新版要求：因为运行 stylelint 后会将 @import './index.scss'; 编译为 @import url('./index.scss'); 导致嵌套样式不生效，大家以后引入样式文件要改为 `<style src="./index.scss" lang="scss" scoped /> 或 <style src="./index.scss" lang="scss" scoped />`

------

## 跟倒计时相关的功能更新

大家查看一下以前自己开发的跟倒计时相关的功能，如果是抢购、竞价之类的有时效的操作，统一改为使用系统时间，参考

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\lQLPJxVLW-chVkbNAlfNBGuwSXNuQmEbCKkEH0g07ICyAA_1131_599.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\lQLPJwGcwlXMUQbM8c0CTLBbJoUC0RuWEwQfSG5dQC8A_588_241.png)

$systemTime对象目前提供两种时间值，time：字符串时间戳，timeMS：毫秒

------

## {}[]是什么用法【有趣的写法】

[引用](https://blog.csdn.net/wl516372370/article/details/111935973)

```js
this.name = () => {
    this.name_code = {
        xiaohong: '小红',
        xiaoming:'小明',
       	xiaolv : '小绿'
    }[this.active_name_code];
}
```

```js
this.name = () => {}
//值 = 箭头函数 【默认一个返回值】
```

```js
this.name_code = {}
```

```apl
{}[] 

obj.name = obj[name] 这两种写法是相同的  当字段中有短横线时就可以使用这种来避免错误
如：obj[name-first] = obj.name-first

就有错误！！！  【obj.name-first】这种写法不可取。。。


```

------

## 深拷贝(四种方法)(为什么要用深拷贝)

[链接](https://blog.csdn.net/weixin_57983561/article/details/117198822?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167963761216800213066131%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167963761216800213066131&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-117198822-null-null.142^v76^wechat,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=%E6%B7%B1%E6%8B%B7%E8%B4%9D&spm=1018.2226.3001.4187)

------

## 关于JSON.parse(JSON.stringify(obj))实现深拷贝应该注意的坑

[yiny](https://blog.csdn.net/suandfei/article/details/102638132?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-102638132-blog-125879881.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-102638132-blog-125879881.235%5Ev27%5Epc_relevant_multi_platform_whitelistv3&utm_relevant_index=1)

> JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify 将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象；我们在使用 JSON.parse(JSON.stringify(xxx))时应该注意一下几点：

### 1、如果obj里面有时间对象，

则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；

```js
 var test = {
    name: 'a',
    date: [new Date(1536627600000), new Date(1540047600000)],
  };

  let b;
  b = JSON.parse(JSON.stringify(test))



```

test 结果.

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019142855159.png)

b的结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019142935795.png)

测试b和test类型

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019143016214.png)

### 2、如果obj里有RegExp、Error对象

，则序列化的结果将只得到空对象；

```js
  const test = {
        name: 'a',
        date: new RegExp('\\w+'),
      };
      // debugger
      const copyed = JSON.parse(JSON.stringify(test));
      test.name = 'test'
      console.error('ddd', test, copyed)

```

测试结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101914351148.png)

### 3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；

```js
   const test = {
        name: 'a',
        date: function hehe() {
          console.log('fff')
        },
      };
      // debugger
      const copyed = JSON.parse(JSON.stringify(test));
      test.name = 'test'
      console.error('ddd', test, copyed)

```

结果

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019143710941.png)

### 4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null  

```js
 const test = {
        name: NaN,
        date: function hehe() {
          console.log('fff')
        },
      };
      // debugger
      const copyed = JSON.parse(JSON.stringify(test));
    
      console.log( test, copyed)
    

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019143916711.png)

### 5、JSON.stringify()只能序列化对象的可枚举的自有属性

，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；

```js
     function Person(name) {
        this.name = name;
        console.log(name)
      }

      const liai = new Person('liai');

      const test = {
        name: 'a',
        date: liai,
      };
      // debugger
      const copyed = JSON.parse(JSON.stringify(test));
      test.name = 'test'
      console.error('ddd', test, copyed)


```

第一个date的构造函数是Person 但是经过序列化再格式化已经失去了原有的构造函数 而是变成了Object

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191019144521233.png)
接下来这个方法比较通用可以参考

接下来这个方法比较通用可以参考

```js
var clone = function (obj) { 
    if(obj === null) return null 
    if(typeof obj !== 'object') return obj;
    if(obj.constructor===Date) return new Date(obj); 
    var newObj = new obj.constructor ();  //保持继承链
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {   //不遍历其原型链上的属性
            var val = obj[key];
            newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合
        }
    }  
    return newObj;  
}; 

```

1. 用new obj.constructor ()构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承; 这样克隆出来的新对象也可以通过原型链访问构造函数的方法
2. 用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for…in…也会遍历其原型链上的可枚举属性。
3. 上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 clone紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。在严格模式下 arguments.callee 被禁用了，可以查看我的其他文章。







------

## 循环调用

![image-20230324163157631](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20230324163157631.png)

对了，以后这种循环调用的方法，最好加上判断条件，不然页面都销毁了，方法还在一直跑

------

## 记录antd组件Form表单的labelCol，wrapperCol怎么用

[原文链接](https://blog.csdn.net/weixin_40878286/article/details/119995653)

记录antd组件Form表单的labelCol，wrapperCol

翻阅文档赫然清晰说明了她两的用法：然而奈何居然都不明白，这到底是怎么回事？

**labelCol**： label 标签布局，同 <Col> 组件，设置 span offset 值，如 {span: 3, offset: 12} 或 sm: {span: 3, offset: 12}。你可以通过 Form 的 labelCol 进行统一设置，，不会作用于嵌套 Item。当和 Form 同时设置时，以 Item 为准。

刚刚开始是真的不明白是什么呢，无奈。

后面发现，言下之意就是可以下面两种设置：

方式一:

```js
<Form
 
labelCol={{span:3}}
 
wrapperCol={{span:8}}
 
></Form>
```

方式二：

```
<Form
 
labelCol={{span:3}}
 
wrapperCol={{span:8}}
 
>
 
<Form.Item >
 
</Form.Item>
 
<Row >
 
.......
<Col span={12}>
 
<Form.Item labelCol={{span:6}} wrapperCol={{16}}>
 
</Form.Item>
 
</Col>
 
<Col span={12}>
 
<Form.Item labelCol={{span:6}} wrapperCol={{16}}>
 
</Form.Item>
 
</Col>
 
</Row>
 
</Form>
```

这样设置的样式会是怎么样的呢，其余的都是一行排列，有两个item是排列到一行的，然后两倍的比列去设置他的占比。外层是3和8.内层由于总的宽只是占了一半，所以内层的占比是6和16。如图所示:nice!

以下是我思考的过程，如果只想要结果的就可以止步于此，不用读了。

![img](https://img-blog.csdnimg.cn/20210830135803437.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_12,color_FFFFFF,t_70,g_se,x_16)

看到官网解释我立马大胆猜测，span是指的是文本的内容，offset是当前组件相对一行的头所偏移的距离。举个例子：

![img](https://img-blog.csdnimg.cn/20210830140113664.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_20,color_FFFFFF,t_70,g_se,x_16)

```js
对应的代码：
<Row><Col span={12} offset={6}> col-12 col-offset-6</Col></Row>
```

解释：span={12} offset={6}12+6=18 看图offset和span一行其实就占了24份的18份 那么还剩下4份就是最右边的白色部分。要合情合理的去猜。好了，你以为你已经很了解这个span和offset了。开心。继续，路还很长。

**wrapperCol**： 需要为输入控件设置布局样式时，使用该属性，用法同 labelCol。你可以通过 Form 的 wrapperCol 进行统一设置，不会作用于嵌套 Item。当和 Form 同时设置时，以 Item 为准

解释：好吧，我真心是读了好几遍，我理解能力真的很差。第一句话： 需要为输入控件设置布局样式时，使用该属性，这句话我完全没有过脑子，其实说的就是输入控件啊，如图啊，这种不就是输入控件嘛，为啥写的这么清楚，就对官网如此不礼貌，不去好好理解别人的话呢。害，为难自己。

![img](https://img-blog.csdnimg.cn/20210830140158247.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_14,color_FFFFFF,t_70,g_se,x_16)

第二句：用法同 labelCol。你可以通过 Form 的 wrapperCol 进行统一设置，不会作用于嵌套 Item。当和 Form 同时设置时，以 Item 为准。现在明白了读一下就豁然开朗，就是如下代码：

```js
<Form
 
labelCol={{span:3}}
 
wrapperCol={{span:8}}
 
>
 
<Form.Item >
 
</Form.Item>
 
<Row >
 
.......
<Col span={12}>
 
<Form.Item labelCol={{span:6}} wrapperCol={{16}}>
 
</Form.Item>
 
</Col>
 
<Col span={12}>
 
<Form.Item labelCol={{span:6}} wrapperCol={{16}}>
 
</Form.Item>
 
</Col>
 
</Row>
 
</Form>
```

用法同 labelCol翻译一下就是说span和offset可以用来设置输入控件的占位情况。举个例子当加上[wrapper](https://so.csdn.net/so/search?q=wrapper&spm=1001.2101.3001.7020)={{span: 8}},就说明占一行24份的8份。那么事情就很清晰明白了。假设我在form中 设置一个

```js
<Form
 
labelCol={{ span: 3 }}
 
wrapperCol={{ span: 8 }}
 
></From>
```

那么这个表单会怎么排列呢，默认会是Horizontal水平排列，又去翻文档还有Vertical垂直排列，以及
Inline内联排列，根据字面意思，最好理解的是内联，其实就是不换行，挨着排列，可以想象成span一个一个挨着排列。如图：

![img](https://img-blog.csdnimg.cn/20210830140446416.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_20,color_FFFFFF,t_70,g_se,x_16)

再来理解Vertical垂直排列，如图：

![img](https://img-blog.csdnimg.cn/20210830140431959.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_20,color_FFFFFF,t_70,g_se,x_16)

垂直排列，整个占一行

![img](https://img-blog.csdnimg.cn/20210830140536653.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQwODc4Mjg2,size_13,color_FFFFFF,t_70,g_se,x_16)

而水平排列的话，文本和输入控件会水平排列。害，一写文档思路就肉眼的清晰了。

现在仔细读读文档的话，是不是就很能理解了呢。

<font color='gree'>labelCol</font>： label 标签布局，同 <Col> 组件，设置 span offset 值，如 {span: 3, offset: 12} 或 sm: {span: 3, offset: 12}。你可以通过 Form 的 labelCol 进行统一设置，，不会作用于嵌套 Item。当和 Form 同时设置时，以 Item 为准。

<font color='gree'>wrapperCol</font>： 需要为输入控件设置布局样式时，使用该属性，用法同 labelCol。你可以通过 Form 的 wrapperCol 进行统一设置，不会作用于嵌套 Item。当和 Form 同时设置时，以 Item 为准。

> labelCol 通常都是指文字标签的内容，而wrapperCol通常是指输入框的内容，而它们之间的总和是24个格，效果可以根据这个24个格慢慢地去调整即可

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-17_16-30-54.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-17_16-32-11.png)

> <font color='gree'>可以理解为在不同屏幕下的span值</font>
>
> <font color='gree'>`:xs="6"` 相当于 `:xs="{ span: 6 }"`</font>

lg=* 一般用于大屏设备（min-width：1200px）

md=* 一般用于中屏设备（min-width：992px）

sm=* 一般用于小屏设备（min-width：768px）

xs =*用于超小型设备（max-width：768px）

(*为1-12数字)

------

## 关于event.preventDefault()的用法

[引用](https://blog.csdn.net/fuyangsuccessful/article/details/128630035)

本来是研究ES6的对象的解构赋值的，自己突发奇想，将表单页面的数据提交到后端对象中的，用纯原生的方式编写代码，结果运行代码没有报错，怎么就获取不到表单输入框输入的内容，百思不得其解。先展示错误代码



   当运行上述代码的时候，打开浏览器，点击提交按钮，控制台结果一闪而过，最后询问大佬，大佬告知我说，from表单是默认提交的，控制台打印肯定不显示的，需要做的是阻止默认事件就ok了，然后给我指出使用event.preventDefault()。

   event.preventDefault()是何方法宝？那么厉害呢？以前学艺不精忘记了，这里在复习一遍。

event.preventDefault()方法是用于取消事件的默认行为，例如，当点击提交按钮时阻止对表单的提交。但此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。

其实就是用来取消时间的默认动作。

注意

1、如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。

2、此方法并不被ie支持，在ie下需要用window.event.returnValue = false; 来实现。

修改后的代码就是需要添加event.preventDefault()，代码如下所示：



 在上面代码中还有一个知识点就是ES6的对象解构赋值，在一个对象中，当属性（key）与属性值(前面定义的变量)一样的时候，是可以省略的，可以只写一个（key）属性

------

## v-model.trim用法及其他修饰符

[引用](https://blog.csdn.net/canyi8023/article/details/120312895)

**v-model的修饰符
v-model.lazy 只有在input输入框发生一个blur时才触发
v-model.trim 将用户输入的前后的空格去掉
v-model.number 将用户输入的字符串转换成number
在input textarea select中使用**

在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。

为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。

.stop
.prevent
.capture
.self
.once

```html
<!-- 阻止单击事件冒泡 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件侦听器时使用事件捕获模式 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当事件在该元素本身（比如不是子元素）触发时触发回调 -->
<div v-on:click.self="doThat">...</div>
```

使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 @click.prevent.self 会阻止所有的点击，而 @click.self.prevent 只会阻止元素上的点击。

------

## this.$emit()

> [引用](https://blog.csdn.net/qq_26386437/article/details/108590530)
>
> [Vue中input组件的封装以及v-model的深层解析](https://zhuanlan.zhihu.com/p/335978145)
>
> [vue子组件怎么调用父组件的方法](https://www.php.cn/faq/483395.html)

this.$emit()

> 作用：子组件向父组件传值

```js
//在子组件中需要向父组件传值处使用this.$emit
this.$emit("function",param);
this.$emit("函数方法名字",传值名字)

eg：
<input :value="parentData"
    @input="$emit('changeValue', $event.target.value)" type="text">
------------
在script中使用 this.$emit("function",param);
```

```js
// 在父组件中子组件引用处添加函数
v-on:function="function1"；
@子组件中定义函数="父组件定义函数"
 //其中function为子组件中定义函数，function1为父组件定义函数--用于接收子组件传值并进行相应数据处理，可定义为同一名称
 @ 为 v-on
```

**子组件**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200914233659632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_20,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2Mzg2NDM3,size_1,color_FFFFFF,t_70#pic_center)

**父组件调用changeTitel方法**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200914233835565.png#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200914233855665.png#pic_center)

实现了子组件点击父组件能获取到值

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200914233926542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2Mzg2NDM3,size_16,color_FFFFFF,t_70#pic_center)

> 也可以 
>
> ```js
> // 父
> <children :model="info"
>       @demand-change="currentDemand = $event"></children>
> 
> export default {
> data() {
>     return {
>       currentDemand: 0,
>     };
>   },
>   watch: {
>     currentDemand() {
>       this.currentDemand = 0;
>       this.$emit('quote-change', 1);
>     },
>   },
> // 子
> this.$emit('demand-change', 1);
> ```

------

## $event

`$event`是Vue.js框架中的一个特殊变量，用于在组件的事件处理函数中访问事件对象。在Vue.js中，当我们在模板中绑定事件时，Vue.js会自动将事件对象作为参数传递给事件处理函数。我们可以使用`$event`变量来访问这个事件对象，以便获取事件的相关信息或者进行事件的操作。

以下是一个使用`$event`变量访问事件对象的示例：

```vue
// html复制代码
<template>
  <div>
    <button @click="handleClick($event)">点击我</button>
  </div>
</template>

<script>
export default {
  methods: {
    handleClick(event) {
      console.log(event); // 打印事件对象
      console.log(event.target); // 打印事件目标
      console.log(event.clientX, event.clientY); // 打印鼠标位置
      event.preventDefault(); // 阻止默认行为
    }
  }
};
</script>
```

在这个示例中，我们在`<button>`元素上绑定了`@click`事件，并将事件对象作为参数传递给`handleClick`方法。在`handleClick`方法中，我们可以使用`$event`变量访问事件对象，并获取事件的相关信息或者进行事件的操作。例如，我们可以打印事件对象、事件目标、鼠标位置等信息，以便调试和开发。

需要注意的是，由于`$event`变量是一个特殊变量，因此我们不能在模板中直接使用它。如果我们需要在模板中访问事件对象，可以通过绑定计算属性或者使用组件间通信的方式来实现。

------

## 字符串转数组然后替换转字符换

```js
/ 将成绩数据按照空格进行分割
    const arrOld = dataStr.split(' ');

    // 循环分割后的数组，对每一项数据进行字符串的替换操作
    const arrNew = [];
    arrOld.forEach(item => {
        arrNew.push(item.replace('=', '：'));
    })

    // 把新数组中的每一项进行合并，得到一个新的字符串
    const newStr = arrNew.join('\r\n');

```



------

## CSS Flex 布局的引入背景

[引入](https://www.jianshu.com/p/526df5aa5812)

flex 布局背后的主要思想是让容器能够改变其项目的宽度/高度（和顺序）以自适应地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。弹性容器扩展 item 以填充可用的可用空间，在必要时也会收缩容器内元素的宽度，以防止溢出(overflow)

由于 flexbox 是一个完整的模块而不是一个单一的属性，它涉及很多东西，包括它的整个属性集。 其中一些要设置在容器（父元素，称为 `flex container`）上，而剩下的属性要设置在子元素（称为 `flex item`）上。

如果常规布局基于块和内联流向，则弹性布局基于弹性流向。 下面这张图解释了 flex 布局背后的主要思想。

![img](https://upload-images.jianshu.io/upload_images/2085791-2eb070731e6daea8.png?imageMogr2/auto-orient/strip|imageView2/2/w/982/format/webp)

Flex 容器里的 items 元素，要么沿着 main 轴方向布局，要么沿着 cross 轴方向布局。

Flex 容器和容器里的 item 元素的对应关系如下图所示：

![img](https://upload-images.jianshu.io/upload_images/2085791-d107ce2d3941e4b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1181/format/webp)

display:flex 这个 css 属性即可将一个容器设置成 `Flex` 布局的容器：

![img](https://upload-images.jianshu.io/upload_images/2085791-788198ce64d1fb64.png?imageMogr2/auto-orient/strip|imageView2/2/w/449/format/webp)

------

## isEmpty()

判断是否为空

------

## export和export default

[引用](https://blog.csdn.net/liuqiao0327/article/details/107366010?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107366010-blog-128775545.235%5Ev28%5Epc_relevant_t0_download&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-107366010-blog-128775545.235%5Ev28%5Epc_relevant_t0_download&utm_relevant_index=2) [ES6中export default详解](https://blog.csdn.net/Andrew_SJ/article/details/118681168?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-118681168-blog-106425246.235^v28^pc_relevant_t0_download&spm=1001.2101.3001.4242.2&utm_relevant_index=4)

### 一.背景

> 最近好几个小兄弟都问了我export 和export default导出的时候的区别,当时跟他们也只是说了个大概,今天这里多总结一下.

### 二.论区别

> 这个export的由来是来源于[ES6](https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020)的模块功能,ES6的模块功能主要由2个命令构成:`export`和`import`

- export命令用于固定模块的对外接口
- import命令用于引入其他模块提供的功能

#### 1.export

> export可以导出常量,变量,函数,文件,类,模块等等

```js
export const msg = 'hello';
export var hello='1234';
export function foo(){

}
export class Person{

}

```

上述代码中,使用export抛出了`常量,变量,函数,类`,一个js文件中,可以使用export抛出多个数据(指变量常量函数等等).这种写法还有另一种写法:

```js
const msg = 'hello';
var hello = '1234';
function foo() {

}
class Person {

}
export {
    msg as info, hello, foo, Person
}

```

在最底部抛出,使用大括号包起来,相当于抛出了一个大对象,一般我们建议这么写,这样很容易清楚的知道抛出去了什么.另外,我们还可以使用 `msg as info` 来起别名

#### 2.export default

> 一个文件或模块中,export 可以有多个,但是export default仅有一个

```js
var world = '2345';
export default world;
//实际上这里的default是给抛出去的数据起了一个系统默认的名字,所以只能有一个,不能有多个

```

PS: export default 后面没有必要加大括号 `{}`,因为根本没必要再使用一个类将他包起来

#### 3.import

> ES6 中,使用import导入模块,可以导入export抛出来的任何东西,也可以导入路径,比如样式文件

使用 `import xxxx from 'xxxxxx'`导入模块,在我们使用import导入的时候,导入方式是对应着export如何导出的.

如果是用export导出

```js
import { msg, hello, foo, Person } from './test';

//也可以分批导入
import { msg} from './test';
import { hello} from './test';
import { foo} from './test';
import { Person} from './test';


```

使用这种方式导出的,我们在import接收的时候,必须使用大括号接收,因为export导出,相当于导出了一个大的对象,我们需要使用解构的方式来接收.

如果是export default导出

```js
//变量名可以随便写
import obj from './test';


```

使用这种方式导出的,没有必要使用大括号,因为导出时就是一个默认的default名字,所有不需要写大括号

### 三.总结

1.export与export default都可用于导出常量、函数、类、文件、模块等

2.通过import (常量,函数,文件,类,模块,)名的方式,还可以根据路径导入样式文件，导入

3.一个文件模块中,export和import可以有多个,但是export default只能有一个

4.export default 暴露的成员可以用任意变量来接收

5.一个文件模块中,可以同时使用export和export default向外暴露成员,只不过接收方式不一样

6.通过export方式导出,在导入时必须要使用大括号{}来接收,export default则不需要

7.通过export方式导出,可以使用 as起别名进行导出

------

## 正则

```js
priceClass: item.floats > 0 ? 'red' : item.floats < 0 ? 'green' : 'gray3'
```

```js
// 定义正则表达式 分别匹配 <style></style> 和 <script></script> 标签
// 其中 \s 表示空白字符，\S 表示非空白字符，* 表示匹配任意次。</style> 中的 / 需要加 "\" 转义
const regStyle = /<style>[\s\S]*<\/style>/
const regScript = /<script>[\s\S]*<\/script>/
```

### exec()函数的使用

1. exec()函数作用：

> exec()函数用于检索字符串中正则表达式的匹配
> 如果有匹配的值则返回该函数的值，
>
> **返回值是一个数组 ** ，此数组的第0个元素是与正则表达式相匹配的文本
>
> 如果没有则返回null。

> 可以查找正则表达式在字符串中的位置等

2. 基本语法：

```js
RegExpObject(正则表达式).exec(string(字符串))
```

3. 举例

匹配成功：

```js
// 返回值是一个数组 
var str = 'love';
    var pattern = /o/;
    console.log(pattern.exec(str));
```

运行结果：

![img](https://img-blog.csdnimg.cn/96b519cbb35240ecae42db973582db9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTcyOTY3MDA=,size_15,color_FFFFFF,t_70,g_se,x_16)

 匹配失败

```js
var str = 'love';
    var pattern = /x/;
    console.log(pattern.exec(str));
```

![img](https://img-blog.csdnimg.cn/b0aaaafecc57433a89c1f3fd5a4f89e1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbTBfNTcyOTY3MDA=,size_13,color_FFFFFF,t_70,g_se,x_16)

------

## ||  运算符

（比如let a = b || c）

JavaScript
1、JS中的||符号：
运算方法：
只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。
只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。
比如：var a= b || c
这相当于一个赋值语句，如果b的值被转换为false，那么就把c的值赋给a，否在就把b的值赋给a
javascript中以下值会被转换为false

------



## encodeURI() 函数

```
var uri="my test.php?name=ståle&car=saab";
document.write(encodeURI(uri)+ "<br>");
```

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-29_11-51-15.png)

------

## includes()

[网址](https://www.cnblogs.com/webSnow/p/16121867.html)

```
js中的includes用法

1.数组
includes 可以判断一个数组中是否包含某一个元素，并返回true 或者false
['a','b','c'].includes('a')
true

['a','b','c'].includes(1)
false


includes可以包含两个参数，第二个参数表示判断的起始位置

起始位置第一个数字是0。
2.字符串  查找字符串是否包含 "Runoob":
  var str = "Hello world, welcome to the Runoob。"; var n = str.includes("Runoob");
  n 输出结果:  true
```

------

## ?.  运算符的使用

## 可选链操作符(?.)

1. 可选链操作符( **`?.`** )允许<font color='gree'>读取位于连接对象链深处的属性的值</font>，而不必明确验证链中的每个引用是否有效。
2. `?.` 操作符的功能类似于 `.` 链式操作符，不同之处在于，<font color='gree'>在引用为空([nullish](https://wiki.developer.mozilla.org/en-US/docs/Glossary/nullish) ) ([`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或者 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)) 的情况下不会引起错误</font>，该表达式短路返回值

> <font color='gree'>常用于替换`.`来实现防止空值导致的报错</font>

语法

```scss
obj?.prop
obj?.[expr]
func?.(args)
```

### **使用介绍**

比如，我们有一个对象obj，现在要访问它的深层属性baz。

```js
const obj = {
  foo: {
    bar: {
      baz: 42,
      fun: ()=>{}
    },
  },
};
 
// 不使用?.
let baz = obj && obj.foo && obj.foo.bar && obj.foo.bar.baz;
 
// 使用?.
let baz = obj?.foo?.bar?.baz; // 结果：42
 
 
 
```

函数调用和表达式

>```js
>// 函数调用
>obj.fn?.()
>// 表达式
>obj?.['prop' + 'Name]
>```



 **【防止报错和短路】**

作用就是判断这个对象（this.element）下的（Object）下的（value）下的（length）是否为null或者undefined，
(如果没有加 ?. ，有的时候会报length是null 的错误，或者说 null length 没有定义，然有了?. 就省去了好多麻烦)
当其中一链为null或者undefined时就返回undefined，这样即使中间缺少一个属性也不会报错，

![在这里插入图片描述](https://img-blog.csdnimg.cn/a3c67f0066f94d94945348021ca72e68.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAYnVn6Lev5LiK55qEYnVn,size_20,color_FFFFFF,t_70,g_se,x_16)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-01_14-57-30.png)

如果 item.admissionDeposit 为空会报错，最好改成 item.admissionDeposit?.toString()?.split('.')?.[0]

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-01_14-57-48.png)

如果 e 是整数会报错，最好改成 num[1]?.length

## **空值合并操作符**（**`??`**）

只有当左侧为null和undefined时，才会返回右侧的数

　　空值合并操作符（`??`）是一个逻辑操作符，当左侧的操作数为 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或者 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 时，返回其右侧操作数，否则返回左侧操作数。

　　与[逻辑或操作符（`||`）](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Logical_OR_2)不同，逻辑或操作符会在左侧操作数为[假值](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)时返回右侧操作数。也就是说，如果使用 `||` 来为某些变量设置默认值，可能会遇到意料之外的行为。比如为假值（例如，`''` 或 `0`）时。见下面的例子。

> **值得注意的是 ：?? 是忽视 null ,undefined 等错误的值**
>
> <font color='gree'>可以把 || 换成使用 ??，这样可以避免 数字0 也会触发 || 运算</font>

```js
const foo = null ?? 'default string';
console.log(foo);
// expected output: "default string"

const baz = 0 ?? 42;
console.log(baz);
// expected output: 0
```

```js
const nullValue = null;
const emptyText = ""; // 空字符串，是一个假值，Boolean("") === false
const someNumber = 42;

const valA = nullValue ?? "valA 的默认值";
const valB = emptyText ?? "valB 的默认值";
const valC = someNumber ?? 0;

console.log(valA); // "valA 的默认值"
console.log(valB); // ""（空字符串虽然是假值，但不是 null 或者 undefined）
console.log(valC); // 42
```

## 空值赋值运算符(`??=`)

和上面的例子类似

```js
let b = '你好';
let a = 0
let c = null;
let d = ’123‘
b ??= a;  // b = “你好”
c ??= d  // c = '123'
```

> <font color='gree'>当??=左侧的值为null、undefined的时候,才会将右侧变量的值赋值给左侧变量.其他所有值都不会进行赋值</font>.同样在一些场景下,可以省略很多代码.



------

## ...  扩展运算符

### 什么意思？

三个点（...）真名叫扩展[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)，是在ES6中新增加的内容，它可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造字面量对象时将对象表达式按照key-value的方式展开

> 字面量一般指[1,2,3]或者{name:'chuichui'}这种简洁的构造方式,多层嵌套的数组和对象三个点就无能为力了

```js
// 数组
var number = [1,2,3,4,5,6]
console.log(...number) //1 2 3 4 5 6
//对象
var man = {name:'chuichui',height:176}
console.log({...man}) / {name:'chuichui',height:176}
```

### 有什么用？

它的用处很广泛，我们随处都可以看到，下面是几个常见的例子

#### 复制用它

```js
//数组的复制
var arr1 = ['hello']
var arr2 =[...arr1]
arr2 // ['hello']
//对象的复制
var obj1 = {name:'chuichui'}
var obj2 ={...arr}
ob12 //  {name:'chuichui'}
```

#### 合并用它

```js
//数组的合并
var arr1 = ['hello']
var arr2 =['chuichui']
var mergeArr = [...arr1,...arr2]
mergeArr  // ['hello','chuichui']
// 对象分合并
var obj1 = {name:'chuichui'}
var obj2 = {height:176}
var mergeObj = {...obj1,...obj2}
mergeObj // {name: "chuichui", height: 176}
```

#### 字符转数组用它

```js
var arr1 = [...'hello']
arr1 // ["h", "e", "l", "l", "o"]
```

#### 函数传参用它

可以和正常的函数相结合，灵活使用

```js
function f(v,w,x,y,z){ }
var args = [2,3]
f(1,...args,4,...[5])
```

当我们想把数组中的元素迭代为函数参数时，用它！

```js
function f(x,y,z){}
var args = [1,2,3]
f(...args)
 
// 以前的方法
f.apply(null,args);
```

------

## Promise

> `Promise `是一个 `ECMAScript 6 `提供的类，目的是更加优雅地书写复杂的异步任务。

### 构造 `Promise`

现在我们新建一个` Promise `对象：

```js
new Promise(function (resolve, reject) {
    // 要做的事情...
});
```

通过新建一个` Promise `对象好像并没有看出它怎样 "更加优雅地书写复杂的异步任务"。我们之前遇到的异步任务都是一次异步，如果需要多次调用异步函数呢？例如，如果我想分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒：

```js
setTimeout(function () {
    console.log("First");
    setTimeout(function () {
        console.log("Second");
        setTimeout(function () {
            console.log("Third");
        }, 3000);
    }, 4000);
}, 1000);
```

这段程序实现了这个功能，但是它是用 "函数瀑布" 来实现的。可想而知，在一个复杂的程序当中，用 "函数瀑布" 实现的程序无论是维护还是异常处理都是一件特别繁琐的事情，而且会让缩进格式变得非常冗赘。

**现在我们用` Promise `来实现同样的功能：**

```js
new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log("First");
        resolve();
    }, 1000);
}).then(function () {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("Second");
            resolve();
        }, 4000);
    });
}).then(function () {
    setTimeout(function () {
        console.log("Third");
    }, 3000);
});
```

 <font color='red'>`Promise `将嵌套格式的代码变成了顺序格式的代码。</font>

### `Promise `的使用

下面我们通过剖析这段 Promise "计时器" 代码来讲述 Promise 的使用：

`Promise `构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数<font color='red'>` resolve `</font>和<font color='red'>` reject`</font>。

当` Promise `被构造时，起始函数会被异步执行：

```js
new Promise(function (resolve, reject) {
    console.log("Run");
});
```

这段程序会直接输出 **Run**。

<font color='red'>`resolve `和` reject `都是函数，其中调用` resolve `代表一切正常，`reject `是出现异常时所调用的：</font>

```js
new Promise(function (resolve, reject) {
    var a = 0;
    var b = 1;
    if (b == 0) reject("Divide zero");
    else resolve(a / b);
}).then(function (value) {
    console.log("a / b = " + value);
}).catch(function (err) {
    console.log(err);
}).finally(function () {
    console.log("End");
});
```

这段程序执行结果是:

```js
a / b = 0
End
```

`Promise` 类有` .then() .catch() `和` .finally() `三个方法，这三个方法的参数都是一个函数，`.then() `可以将参数中的函数添加到当前 Promise 的正常执行序列，`.catch() `则是设定` Promise `的异常处理序列，`.finally() `是在` Promise `执行的最后一定会执行的序列。` .then() `传入的函数会按顺序依次执行，有任何异常都会直接跳到` catch `序列：

```js
new Promise(function (resolve, reject) {
    console.log(1111);
    resolve(2222);
}).then(function (value) {
    console.log(value);
    return 3333;
}).then(function (value) {
    console.log(value);
    throw "An error";
}).catch(function (err) {
    console.log(err);
});
```

执行结果：

```js
1111
2222
3333
An error
```

<font color='red'>`resolve() `中可以放置一个参数用于向下一个` then `传递一个值，`then `中的函数也可以返回一个值传递给` then`。但是，如果` then `中返回的是一个` Promise `对象，那么下一个` then `将相当于对这个返回的` Promise `进行操作，这一点从刚才的计时器的例子中可以看出来。</font>

`reject() `参数中一般会传递一个异常给之后的 catch 函数用于处理异常。

<font color='red'>**但是请注意以下两点：**</font>

- **`resolve `和` reject `的作用域只有起始函数**，不包括` then `以及其他序列；
- `resolve `和` reject `并不能够使起始函数停止运行，别忘了` return`。

### `Promise `函数

上述的 "计时器" 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个**自定义的` Promise` 函数**：

```js
function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}
```

然后我们就可以放心大胆的实现程序功能了：**（调用函数）**

```js
print(1000, "First").then(function () {
    return print(4000, "Second");
}).then(function () {
    print(3000, "Third");
});
```

### 回答常见的问题（FAQ）

>**Q: then、catch 和 finally 序列能否顺序颠倒？**
>
>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。

> **Q: 除了 then 块以外，其它两种块能否多次使用？**
>
> A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。

> **Q: then 块如何中断？**
>
> A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。

> **Q: 什么时候适合用 Promise 而不是传统回调函数？**
>
> A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。

> **Q: Promise 是一种将异步转换为同步的方法吗？**
>
> A: 完全不是。Promise 只不过是一种更良好的编程风格。

> **Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？**
>
> A: 当你又需要调用一个异步任务的时候。

### 异步函数

异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。

在 Promise 中我们编写过一个 Promise 函数：

```js
function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}
```

然后用不同的时间间隔输出了三行文本：**(调用)**

```js
print(1000, "First").then(function () {
    return print(4000, "Second");
}).then(function () {
    print(3000, "Third");
});
```

我们可以将这段代码变得更好看：

```js
async function asyncFunc() {
    await print(1000, "First");
    await print(4000, "Second");
    await print(3000, "Third");
}
asyncFunc();
```

哈！这岂不是将异步操作变得像同步操作一样容易了吗！

这次的回答是肯定的，异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。

异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。

处理异常的机制将用 try-catch 块实现：

```js
async function asyncFunc() {
    try {
        await new Promise(function (resolve, reject) {
            throw "Some error"; // 或者 reject("Some error")
        });
    } catch (err) {
        console.log(err);
        // 会输出 Some error
    }
}
asyncFunc();
```

如果 Promise 有一个正常的返回值，await 语句也会返回它：

```js
async function asyncFunc() {
    let value = await new Promise(
        function (resolve, reject) {
            resolve("Return value");
        }
    );
    console.log(value);
}
asyncFunc();
```

程序会输出:

```js
Return value
```



------

## async 

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

```js
async function name([param[, param[, ... param]]]) { statements }
```

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

```js
async function helloAsync(){
    return "helloAsync";
  }
  
console.log(helloAsync())  // Promise {<resolved>: "helloAsync"}
 
helloAsync().then(v=>{
   console.log(v);         // helloAsync
})
```

async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。

await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。

```js
function testAwait(){
   return new Promise((resolve) => {
       setTimeout(function(){
          console.log("testAwait");
          resolve();
       }, 1000);
   });
}
 
async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
 }
helloAsync();
// testAwait
// helloAsync
```

## await

await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。

### 语法

```
[return_value] = await expression;
```

- expression: 一个 Promise 对象或者任何要等待的值。

### 返回值

返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。

如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。

```js
function testAwait (x) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}
 
async function helloAsync() {
  var x = await testAwait ("hello world");
  console.log(x); 
}
helloAsync ();
// hello world
```

正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。

```js
function testAwait(){
   console.log("testAwait");
}
async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
}
helloAsync();
// testAwait
// helloAsync
```

await针对所跟不同表达式的处理方式：

- Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。
- 非 Promise 对象：直接返回对应的值。

示例：

```js
test() {
      async function a() {
        await console.log('2')

        console.log('1')
      }
      a()
      console.log('3')
      console.log('3')
      console.log('3')
      console.log('3')
    }
test()

// 输出
2
3
3
3
3
1
```

------

## * 在vue中使用rules对表单字段进行验证

> vue 中[表单](https://so.csdn.net/so/search?q=表单&spm=1001.2101.3001.7020)字段验证的写法和方式有多种，本博客介绍三种较为常用的验证方式。

### 1.写在data里的验证

```vue
<!-- 表单 -->
<el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px">
    <el-form-item label="用户名称:" prop="userName">
       <el-input v-model="rulesForm.userName" style="width:300px" maxlength="50"/>
    </el-form-item>
</el-form>
```

- `<el-form>`：代表这是一个表单
- `<el-form>` -> `ref`：表单被引用时的名称，标识
- `<el-form>` -> `rules`：表单验证规则
- `<el-form>` -> `model`：表单数据对象
- `<el-form>` -> `label-width`：表单域标签的宽度，作为 Form 直接子元素的 form-item 会继承该值
- `<el-form>` -> `<el-form-item>`：表单中的每一项子元素
- `<el-form-item>` -> `label`：标签文本
- `<el-form-item>` -> `prop`：表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的
- `<el-input>`：输入框
- `<el-input>` -> `v-model`：绑定的表单数据对象属性
- `<el-input>` -> `style`：行内样式
- `<el-input>` -> `maxlength`：最大字符长度限制

**data 数据**

```js
data() {
    return {
        // 省略别的数据定义
        ...
        
        // 表单验证
        formRules: {
            userName: [
                {required: true,message: "请输入用户名称",trigger: "blur"}
            ]
        }
    }
}
```

- `formRules`：与上文  '表单内容' 中 `<el-form>` 表单的 `:rules` 属性值相同
- `userName`：与上文 '表单内容' 中 `<el-form-item>` 表单子元素的 `prop` 属性值相同
- **`验证内容是：必填，失去焦点时验证，如果为空，提示信息为 '请输入用户名称'`**

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\image-20221025143212122.png)

------

###  **2. 写在行内**

**表单内容**:

```vue
<!-- 表单 -->
<el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px">
    <el-form-item label="银行名称:" prop="accountName" :rules="[{required:true,message:'请输入银行名称',trigger:'blur'}]">
        <el-input v-model="rulesForm.accountName" style="width:300px" maxlength="50"/>
    </el-form-item>
</el-form>
```

- `<el-form-item>` -> `rules`：和第一种方式表现的效果一致，只是写法不一样，这里不再赘述

**data 数据没有内容**



------

### **3. 引入外部定义的规则**

**表单内容**:

```vue
<!-- 表单 -->
<el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px">
    <el-form-item label="银行卡号:" prop="accountNumber">
       <el-input v-model="rulesForm.accountNumber" style="width:300px" maxlength="19"/>
    </el-form-item>
</el-form>
```

- 表单内容与第一种方式写法一致，这里不再赘述

**script 内容**

> 自定义验证表单时，切记不管什么情况都要执行callback函数！！！

```vue
<script>
// 引入了外部的验证规则
import { validateAccountNumber } from "@/utils/validate";
 
// 判断银行卡账户是否正确
// 自定义验证表单时，切记不管什么情况都要执行callback函数！！！
const validatorAccountNumber = (rule, value, callback) => {
  if (!value) {
    return callback(new Error("请输入账户信息"));
  } else {
    if (validateAccountNumber(value)) {
      callback();
    } else {
      return callback(new Error('账号格式不正确'))
    }
  }
};
 
export default {
    data() {
        return {
            // 省略别的数据定义
            ...
        
            // 表单验证
            // 可以用逗号隔开更多校验规则
            formRules: {
                accountNumber: [
                    {required: true,validator: validatorAccountNumber,trigger: "blur"},
                    {pattern: /^[1-9]\d{0,9}$/, message: '请输入非零的正整数', trigger: 'blur'},
                    {validator: num9, trigger: 'blur'},
                    {validator: num9, trigger: 'blur'},
                ]
            }
        }
    }
}
</script>
```

- `import`：先引入了外部的验证规则 
- `const`：定义一个规则常量，常量名可变， '= (rule, value, callback) => {}' 为固定格式，`value` 入参为验证的字段值
- `formRules` -> `accountNumber`：表单验证中使用 validator 指定自定义校验规则常量名称

**validate.js**

```js
/* 银行账户 */
export function validateAccountNumber(str) {
  const reg = /^([1-9]{1})(\d{14}|\d{18})$/
  return reg.test(str)
}
```

- 验证规则

实例2：

```js
data() {
    const num10 = (rule, value, callback) => {
      if (value == '' || value == undefined || value == null) {
        callback();
      } else {
        const t = /^([+]?\d{1,9})$/;
        if (!t.test(value)) {
          callback(new Error('请输入1-9位正整数！'));
        }
        callback();
    const num8 = (rule, value, callback) => {
      if (value == '' || value == undefined || value == null) {
        callback();
      } else {
        const z = /^([+]?\d{1,8})(\.\d{1,2})?$/;
        if (!z.test(value)) {
          callback(new Error('请输入不超过8位数，可输入2位小数'));
        }
        callback();
      }
    };

```



------

#### **以上都是在失去焦点时的验证，下面来分析一下如何在表单提交时验证

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-16_16-05-48.png)

##### <font color='red'>this.$refs[formName].validate</font>

><font color='gree'>`this.$refs[formName].validate` 也可以写成 `this.$refs.formName.validate` 就可以不需要`@click="onSubmit('rulesForm')"`的时候不用传参`rulesForm`了</font>
>
><font color='gree'>移动端`vant`框架下无法使用上述两种方法，具体详情查看《移动端validate部分》</font>

 **1. 表单的提交按钮**

```vue
<!-- 表单 -->
<el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px">
    <el-form-item>
        <el-button type="primary" @click="onSubmit('rulesForm')">保存</el-button>
        <el-button @click="cancel">取消</el-button>
    </el-form-item>
</el-form>
```

- `<el-button>`：按钮
- `<el-button>`-> `type`：按钮类型
- `<el-button>` -> `@click`：按钮点击时触发的事件，这里注意方法的入参为 'rulesForm'，这里要与 `<el-form>` 表单的 rel 属性值一致

 **2. methods 方法**

```js
methods: {
    // 保存
    onSubmit(formName) {
        this.$refs[formName].validate(valid => {
            if (valid) {
                // valid 值为true或false
                // 成功通道
                console.log("success submit!!");
            }else{
                // 失败通道
                console.log("error submit!!");
                return false;
            }
        });
    },
    // 取消
    cancel() {
        
    }
}
```

- `this.$refs[formName].validate：中的 formName` 就是传入的 'rulesForm'，与 `<el-form>` 表单的 `rel` 属性值一致，这样就指定好需要验证的表单了
- 然后要结合`validate.js`来判断的话必须要有`validate.js`

------

**完整示例代码如下**：

**1. rules.vue**：

```vue
<template>
  <div class="app-container">
    <el-tabs v-model="activeName">
      <el-tab-pane label="表单" name="rulesPane" @tab-click="handleClick">
        <!-- 表单 -->
        <el-form ref="rulesForm" :rules="formRules" :model="rulesForm" label-width="200px">
          <el-form-item label="用户名称:" prop="userName">
            <el-input v-model="rulesForm.userName" style="width:300px" maxlength="50"/>
          </el-form-item>
          <el-form-item label="银行名称:" prop="accountName" :rules="[{required:true,message:'请输入银行名称',trigger:'blur'}]">
            <el-input v-model="rulesForm.accountName" style="width:300px" maxlength="50"/>
          </el-form-item>
          <el-form-item label="银行卡号:" prop="accountNumber">
            <el-input v-model="rulesForm.accountNumber" style="width:300px" maxlength="50"/>
          </el-form-item>
          <el-form-item>
            <el-button type="primary" @click="onSubmit('rulesForm')">保存</el-button>
            <el-button @click="cancel">取消</el-button>
          </el-form-item>
        </el-form>
      </el-tab-pane>
    </el-tabs>
  </div>
</template>
 
<script>
import { validateAccountNumber } from "@/utils/validate";
 
// 判断银行卡账户是否正确
// 自定义验证表单时，切记不管什么情况都要执行callback函数！！！
const validatorAccountNumber = (rule, value, callback) => {
  if (!value) {
    return callback(new Error("请输入账户信息"));
  } else {
    if (validateAccountNumber(value)) {
      callback();
    } else {
      return callback(new Error('账号格式不正确'))
    }
  }
};
 
export default {
  name: "rules",
  data() {
    return {
      activeName: "rulesPane",
      defaultProps: {
        children: "children",
        label: "label"
      },
      rulesForm: {
      },
      //   表单验证
      formRules: {
        userName: [
          {
            required: true,
            message: "请输入用户名称",
            trigger: "blur"
          }
        ],
        accountNumber: [
          {
            required: true,
            validator: validatorAccountNumber,
            trigger: "blur"
          }
        ],
      }
    };
  },
  created() {},
  mounted() {},
  methods: {
    handleClick(tab) {
      
    },
    // 取消
    cancel() {
      
    },
    // 保存
    onSubmit(formName) {
      this.$refs[formName].validate(valid => {
        if (valid) {
          console.log("success submit!!");
          // 通常在这里添加 if判断 来进行业务判断，然后通过接口提交数据
          if(xxx>xxx){
             this.$message.error('错误提示');
             return false;
		 }
          if(xxx>xxx){
             this.$message.error('错误提示');
             return false;
		 }
        } else {
          console.log("error submit!!");
          // return false 用于提交失败 （完全执行则提交成功）
          return false;
        }
      });
    }
  }
};
</script>
 
<style lang="scss">
</style>
```

**2. validate.js**

```js
/* 银行账户 */
export function validateAccountNumber(str) {
  const reg = /^([1-9]{1})(\d{14}|\d{18})$/
  return reg.test(str)
}
```

**效果图**	

![rules](https://img-blog.csdnimg.cn/20190108111721773.gif)

```js
// 一个项目例子
onSubmit(state) {
      // 管道气 获取管道气表单数据
      if (this.isPipeLineGas) {
        this.$refs.ruleForm.validate();
        this.$refs.pipelineGasForm.onSubmit();
        if (!this.pipelineValidate) {
          return;
        }
      }
      const data = this.handleFormat(state);
      console.log(data, 'submit====data');

      this.$refs.ruleForm.validate(valid => {
        if (valid) {
          if (this.isNaturalGas) {
            //最低采购量：需限制大于等于运输标准，且允许1-10位正整数
            if (parseInt(data.transportStandard) > parseInt(data.minPurchase)) {
              this.$message.error('起售量需大于等于运输标准！');
              return false;
            }
            if (
              data.transportStandard &&
              parseInt(data.minPurchase) % parseInt(data.transportStandard) != 0
            ) {
              this.$message.error('起售量需为运输标准的倍数！');
              return false;
            }
            if (
              data.singleIncrease &&
              data.transportStandard &&
              parseInt(data.singleIncrease) % parseInt(data.transportStandard) != 0
            ) {
              this.$message.error('单次累加量需为运输标准的倍数');
              return false;
            }
            if (
              data.maxPurchase &&
              parseInt(data.maxPurchase) % parseInt(data.transportStandard) != 0
            ) {
              this.$message.error('最高采购量需为运输标准的倍数！');
              return false;
            }
            // 天然气
            if (
              data.goodsQuantity &&
              data.unlimit == false &&
              parseInt(data.minPurchase) > parseInt(data.goodsQuantity)
            ) {
              this.$message.error('起售量不能超过预售数量');
              return false;
            }
            if (
              data.maxPurchase &&
              data.maxPurchase != '' &&
              data.unlimit == false &&
              parseInt(data.maxPurchase) > parseInt(data.goodsQuantity)
            ) {
              this.$message.error('最高采购不能超过预售数量');
              return false;
            }
            if (
              data.maxPurchase &&
              data.maxPurchase != '' &&
              parseInt(data.maxPurchase) <= parseInt(data.minPurchase)
            ) {
              this.$message.error('最高采购量须大于起售量！');
              return false;
            }
            if (
              data.singleIncrease &&
              data.maxPurchase &&
              parseInt(data.singleIncrease) > parseInt(data.maxPurchase)
            ) {
              this.$message.error('单次累加量不能超过最高采购');
              return false;
            }
            if (this.form.salesStatus == this.fixedPreSale) {
              //固定价
              if (!data.startDate || !data.endDate || !data.startTime || !data.endTime) {
                this.$message.warning('请选择交付时间');
                return false;
              }
              console.log(
                this.$moment(data.startDate).format('YYYY-MM-DD') +
                  ' ' +
                  this.$moment(data.startTime).format('HH:mm:ss')
              );
              const startTime = new Date(
                this.$moment(data.startDate).format('YYYY-MM-DD') +
                  ' ' +
                  this.$moment(data.startTime).format('HH:mm:ss')
              ).getTime();
              const endTime = new Date(
                this.$moment(data.endDate).format('YYYY-MM-DD') +
                  ' ' +
                  this.$moment(data.endTime).format('HH:mm:ss')
              ).getTime();
              console.log(startTime);
              console.log(endTime);
              if (startTime >= endTime) {
                this.$message.warning('交付结束时间须大于交付开始时间');
                return false;
              }
            }
          }
          // 判断 cgoodsId是否是设置的虚拟cgoodsId
          // if (!this.hasCgoodsId && data.cgoodsId == this.newCgoodsId) {
          //   // 虚拟数据
          //   data.cgoodsId = ''
          // }

          //  过滤数据
          const filterData = {};
          for (const key in data) {
            if (!this.$isEmpty(data[key])) {
              filterData[key] = typeof data[key] == 'number' ? String(data[key]) : data[key];
            }
          }
          filterData.pngPriceList =
            filterData.pngPriceList &&
            filterData.pngPriceList.map(item => {
              return {
                ...item,
                pngPrice: typeof item.pngPrice == 'number' ? String(item.pngPrice) : item.pngPrice,
                transPrice:
                  typeof item.transPrice == 'number' ? String(item.transPrice) : item.transPrice,
              };
            });
          this.loading = true;
          //判断是否PNG新增编辑都走同一个接口
          if (filterData.gClsId === 'P10002') {
            filterData.containsFreight = filterData.ifContainsFreight;
            filterData.selPressure = filterData.isSelPressure;
            filterData.includeNeutralfee = filterData.includeNeutralFee;
            filterData.footprintPrice = filterData.referencePrice;
            if (!filterData.priceDecimalPlaces) {
              filterData.priceDecimalPlaces =
                filterData.goodsPriceDecimalPlaces + '#' + filterData.pngFeeDecimalPlaces;
            }
            if (filterData.displayrules === '0') {
              filterData.displayrules = '00';
            } else if (filterData.displayrules === '1') {
              filterData.displayrules = '01';
            } else {
              filterData.displayrules = '02';
            }
            //管道气提交接口
            goodsInstSave({ data: filterData, noMessage: true })
              .then(() => {
                if (state == '01') {
                  this.$message.success('保存成功');
                  this.$router.push({
                    path: '/activityGoodsInst/goodsInst',
                    query: {
                      type: '2',
                      tab: '01',
                    },
                  });
                } else {
                  this.$message.success('上架成功');
                  this.$router.push({
                    path: '/activityGoodsInst/goodsInst',
                    query: {
                      type: '2',
                      tab: '02',
                    },
                  });
                }
              })
              .catch(res => {
                this.$message.info(res.response.data.describe);
                if (res.response.data.state === '800001') {
                  //重新赋值精度
                  this.form.goodsPriceDecimalPlaces =
                    res.response.data.results.goodsPriceDecimalPlaces;
                  this.form.pngFeeDecimalPlaces = res.response.data.results.pngFeeDecimalPlaces;
                }
              })
              .finally(() => {
                this.loading = false;
              });
          } else {
            if (!this.isEdit) {
              // 新增
              addGoodsInst({ data: filterData })
                .then(() => {
                  if (state == '01') {
                    this.$message.success('保存成功');
                    this.$router.push({
                      path: '/activityGoodsInst/goodsInst',
                      query: {
                        type: '2',
                        tab: '01',
                      },
                    });
                  } else {
                    this.$message.success('上架成功');
                    this.$router.push({
                      path: '/activityGoodsInst/goodsInst',
                      query: {
                        type: '2',
                        tab: '02',
                      },
                    });
                  }
                  // this.$router.push({
                  //   path: '/activityGoodsInst/goodsInst',
                  //   query: {
                  //     type: '2',
                  //   },
                  // });
                })
                .finally(() => {
                  this.loading = false;
                });
            } else {
              // 修改
              updateGoodsInst({ data: filterData })
                .then(() => {
                  if (state == '01') {
                    this.$message.success('保存成功');
                    this.$router.push({
                      path: '/activityGoodsInst/goodsInst',
                      query: {
                        type: '2',
                        tab: '01',
                      },
                    });
                  } else {
                    this.$message.success('上架成功');
                    this.$router.push({
                      path: '/activityGoodsInst/goodsInst',
                      query: {
                        type: '2',
                        tab: '02',
                      },
                    });
                  }
                })
                .finally(() => {
                  this.loading = false;
                });
            }
          }
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
```

------



##### this.$refs.表单名称.validateField

> 由下可见`this.$refs.表单名称.validate`检验整个表单，`this.$refs.表单名称.validateField`检验单个或特定几个表单
>
> 会忽略其他校验，只校验`['xxx','xxx','xxx']`内prop指定的 输入

```vue
<template>
  <div>
      <a-form-model :model="form" :rules="rules" ref="formModel">
        <!-- 输入1 -->
        <a-form-model-item label="输入框1" prop="testInput1">
          <a-input placeholder="请输入" v-model="form.testInput1"></a-input>
        </a-form-model-item>
        <!-- 输入2 -->
        <a-form-model-item
          label="输入框2"
          prop="testInput2"
        >
          <!-- 这里的validateField没啥用，校验依然要绑定的rules中来实现 示范一下写在template中的validateField -->
          <a-input placeholder="请输入" v-model="form.testInput2" @blur="()=>{this.$refs.formModel.validateField('testInput2')}"></a-input>
        </a-form-model-item>
        <!-- 输入3 -->
        <a-form-model-item label="输入框3" prop="testInput3">
          <a-input placeholder="请输入" v-model="form.testInput3"></a-input>
        </a-form-model-item>
      </a-form-model>
      <!-- 输入3 -->
      
      <a-button @click="onsumit" class="m-10">提交</a-button>
      <a-button @click="cancel">取消</a-button>
  </div>
</template>

<script>
export default {
  name: 'hello',
  data() {
    return {
      form: {
        testInput1: '',
        testInput2: '',
        testInput3: '',
      },
      rules: {
        testInput1: [{ required: true, message: '请输入', trigger: 'blur' }],
        testInput2: [{ required: true, message: '请输入', trigger: 'blur' }],
        testInput3: [{ required: true, message: '请输入1', trigger: 'blur' }]
      }
    }
  },
  methods: {
    onsumit() {
      // validate校验
      // this.$refs.formModel.validate(valid => {
      //   console.log(valid);
      //   if (valid) {
      //     console.log('success submit!!')
      //   } else {
      //     console.log('error submit!!')
      //     return false
      //   }
      // })

      // 只校验 testInput3 输入3
      this.$refs.formModel.validateField(['testInput3'],valid => {
      	// 若校验通过 valid 为空，若检验失败则 valid 值为 校验绑定rules中的 message
        console.log(valid);
        if (!valid) {
          console.log('success submit!!')
        } else {
          console.log('error submit!!')
          return false
        }
      })
      // 在script可通过 this.$refs.formModel.validateField('xxx')来触发校验 一定要在绑定的rules中写有相应的校验条件才能生效！！！
      // this.$refs.formModel.validateField('testInput2')
    },
    cancel() {}
  }
}
</script>

<style lang="less" scoped>
.m-10{
  margin-right: 10px;
}
</style>></style>

```

> 只校验输入框3

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-16_15-47-26.png)

```js
onsumit() {
      this.$refs.formModel.validate(valid => {
        console.log(valid);
        if (valid) {
          console.log('success submit!!')
        } else {
          console.log('error submit!!')
          return false
        }
      })
      // this.$refs.formModel.validateField(['testInput3'],valid => {
      //   console.log(valid);
      //   if (!valid) {
      //     console.log('success submit!!')
      //   } else {
      //     console.log('error submit!!')
      //     return false
      //   }
      // })
      // this.$refs.formModel.validateField('testInput2')
    },
```

> 正常表单校验

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-16_15-49-46.png)

> 在script可通过 this.$refs.formModel.validateField('xxx')来触发校验 一定要在绑定的rules中写有相应的校验条件才能生效！！！

```js
onsumit() {
      // this.$refs.formModel.validate(valid => {
      //   console.log(valid);
      //   if (valid) {
      //     console.log('success submit!!')
      //   } else {
      //     console.log('error submit!!')
      //     return false
      //   }
      // })
      // this.$refs.formModel.validateField(['testInput3'],valid => {
      //   console.log(valid);
      //   if (!valid) {
      //     console.log('success submit!!')
      //   } else {
      //     console.log('error submit!!')
      //     return false
      //   }
      // })
    
   	// 在script可通过 this.$refs.formModel.validateField('xxx')来触发校验 一定要在绑定的rules中写有相应的校验条件才能生效！！！
      this.$refs.formModel.validateField('testInput2')
    },
```

>`this.$refs.formModel.validateField('testInput2')`使用，在script可通过 this.$refs.formModel.validateField('xxx')来触发校验 一定要在绑定的rules中写有相应的校验条件才能生效！！！

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-03-16_15-51-13.png)

------

##### clearValidate()和resetFields()表单校验的用法和区别

[原文](https://blog.csdn.net/zuo_zuo_blog/article/details/101444920)

**1.整个表单的校验移除**

```js
<Form ref="form" rule={this.rules}>
		<FormItem prop="name" label="姓名">
			<Input/>
		</FormItem>
		<FormItem prop="age" label="年龄">
			<Input/>
		</FormItem>
	</Form>
	// 根据判断条件, 移除所有表单项的校验
	if (/*条件*/) {
		this.$refs['form'].clearValidate();
	}

	// 但是有时候只需要移除其中的某一项校验, 如只移除姓名的校验:
	if (/*条件*/) {
		this.$refs['form'].clearValidate(['name']);
	}
	

```

**2.resetFields和clearValidate区别**

```js
this.$refs.form.resetFields(); //移除校验结果并重置字段值
this.$refs.form.clearValidate(); //移除校验结果
// 二者都能清除验证，但是resetFields（）会重置字段值，而在vue中大量用到的数据的绑定，很可能出现
// 同一个数据绑定在多处的情况，如果滥用resetFields很可能造成界面上出现莫名的bug

```

**3.注意**

有可能this.refs[form].clearValidate()方式不识别。需要使用 refs.form.clearValidate();

**4.element-ui中的表单校验**

表单代码

```js
<el-form :label-width="120" :rules="formRules" :model="form" ref="form">
  <el-form-item label="活动名称" prop="name">
    <el-input v-model="form.name"></el-input>
  </el-form-item>
</el-form>
<el-button type="info" @click="save">保存</el-button>
<el-button type="info" @click="empty">重置</el-button>

```

方法

```js
// 校验规则
formRules: {
     name: [
            { required: true, message: '请输入活动名称', trigger: 'blur' },
            { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
     ],
}
/**
 * 保存函数
 */
save（） { 

  this.$refs[form].validate((valid) => {

      if (valid) {

        alert('submit!');

      } else {

        console.log('error submit!!');

        return false;

      }

    });

  }
  //有可能this.$refs[form].validate() 方式不识别。需要使用: this.$refs.form.validate();
})
empty（） { //重置
  //根据需求二选一
  /**
   * 移除校验结果并重置字段值
   * 注：清除表单项name的校验及数值
   */
  this.$refs.form.resetFields(); 
  /**
   * 移除校验结果
   * 注：只清除表单项name的校验，不清楚表单项name的数值
   */
  this.$refs.form.clearValidate('name'); 
})

```

表单方法（Element官网说明）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190926155137944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p1b196dW9fYmxvZw==,size_16,color_FFFFFF,t_70)

相关文章：
Form 表单(Element官网)：
https://element.eleme.cn/#/zh-CN/component/form#form-biao-dan
完整form校验
https://www.cnblogs.com/weiqinl/p/6708993.html

------

#### ** validate和validateField的使用及区别

[原文](https://blog.csdn.net/Alan_ran/article/details/125336443)

> 传参及一些具体的直接点上边官网连接
>
> [yyElement - The world's most popular Vue UI framework](https://element.eleme.cn/#/zh-CN/component/form)

这里我主要说一下实际项目中的使用

- validate 会校验表单的整个属性,只要你给这个字段设置上了rule

```js
 this.$refs.表单名称.validate(async (valid) => {
        if (!valid) {
          //检验不通过走这里
          return;
        }
        //校验通过走这里
    }
```

- validateField  有些时候我们只需要验证表单中的部分字段,其他字段不需要，这时候我们就需要用validateField函数了,<font color='gree'>注意,这里有几个坑大家别踩了</font>

- <font color='gree'>**首先，我们得知道，使用validateField部分校验数组的时候，数组有几位，就会回调几次。当也就是空的时候，表示验证通过，回调返回为“ ”，所以就是，你校验几个规则，就会返回几个结果，如果通过就为“”（空）。**</font>

-  <font color='gree'>**validateField跟validate的区别: 在这两个代码段中已经展示的很清晰了,自己上手跑一跑逻辑就通了 **</font>

```js
 let validateFieldList = [];
      this.$refs.loginForm.validateField(
         //这里要放数组,数组中写上要校验的字段
        ["userName", "password", "mobilePhone"],
        async (valid) => {
          if (!valid) {
            //校验通过走这里,每通过一次,会往这个数组里加一个""
            validateFieldList.push(valid);
 
            //因为我这里总共校验了三个字段,所有最终三个字段都校验成功之后,数组中会有三个""
            if (
              validateFieldList.length == 3 &&
              validateFieldList.every((item) => item === "")
            ) {
              //这里写校验通过的业务逻辑
            }
            //校验不通过走这里
            return;
          }
        }
```

------

#### ** vue使用表单验证时提交无效的解决办法！

> 简而言之：自定义验证表单时，切记不管什么情况都要执行callback函数！！！

```js
submitForm(formName) {
      this.$refs[formName].validate(valid => {
        if (valid) {
          alert("submit!");
        } else {
          console.log("error submit!!");
          return false;
        }
      });
    }

```

表单验证失败时，可以触发"error [submit](https://so.csdn.net/so/search?q=submit&spm=1001.2101.3001.7020)!!"，但是验证通过后就是不触发alert(“submit!”);
反复查看API后发现，原来是自定义表单验证引发的问题！

```js
// 校验邮箱
    const checkEmail = (rule, value, callback) => {
      // eslint-disable-next-line no-useless-escape
      const reg = /^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]{2,3}$/;
      if (!reg.test(value)) {
        callback(new Error("邮箱格式不合法！"));
      }
    };

```

解决办法：
自定义验证表单时，切记不管什么情况都要执行callback函数！！！

```js
// 校验手机号
    const checkPhone = (rule, value, callback) => {
      const reg = /^\d{11}$/;
      if (!reg.test(value)) {
        callback(new Error("手机号必须为11位数字！"));
      } else {
        callback();// 一定要每种情况都执行回调
      }
    };

```

一定要每种情况都执行回调，否则 this.$refs[formName].validate 就算通过也不会执行。

------



### 4. 校验规则

| 参数       | 说明                                                         | 类型                                    | 默认值   |
| :--------- | :----------------------------------------------------------- | :-------------------------------------- | :------- |
| enum       | 枚举类型                                                     | string                                  | -        |
| len        | 字段长度                                                     | number                                  | -        |
| max        | 最大长度                                                     | number                                  | -        |
| message    | 校验文案                                                     | string                                  | -        |
| min        | 最小长度                                                     | number                                  | -        |
| pattern    | 正则表达式校验                                               | RegExp                                  | -        |
| required   | 是否必选                                                     | boolean                                 | `false`  |
| transform  | 校验前转换字段值                                             | function(value) => transformedValue:any | -        |
| type       | 内建校验类型，[可选项](https://github.com/yiminghe/async-validator#type) | string                                  | 'string' |
| validator  | 自定义校验（注意，[callback 必须被调用](https://github.com/ant-design/ant-design/issues/5155)） | function(rule, value, callback)         | -        |
| whitespace | 必选时，空格是否会被视为错误                                 | boolean                                 | `false`  |

#### trigger:‘blur’ OR trigger:‘change’ OR 不设置:

> 对el-input输入框的验证，trigger的值选blur，即失去焦点时进行验证。
>
> 下拉框（el-select）、日期选择器（el-date-picker）、复选框（el-checkbox）、单选框（el-radio）验证时，trigger的值选择change，即当值发生变化时就进行验证。

------

## *【JS】正则表达式总结(用于校验)

**1.数字/货币金额（支持负数、千分位分隔符）**

```js
/(^[-]?[1-9]\d{0,2}($|(,\d{3})*($|(\.\d{1,2}$))))|((^[0](\.\d{1,2})?)|(^[-][0]\.\d{1,2}))$/
```

**2.数字/货币金额 (只支持正数、不支持校验千分位分隔符)**

```
/(^[1-9]([0-9]+)?(\.[0-9]{1,2})?$)|(^(0){1}$)|(^[0-9]\.[0-9]([0-9])?$)/
```

**3.银行卡号（16或19位）**

```
/^([1-9]{1})(\d{15}|\d{18})$/
```

**4.中文姓名**

```
/^([\u4e00-\u9fa5·]{2,10})$/
```

**5.手机号(严谨), 根据工信部2019年最新公布的手机号段**

```
/^1((3[\d])|(4[5,6,7,9])|(5[0-3,5-9])|(6[5-7])|(7[0-8])|(8[\d])|(9[1,8,9]))\d{8}$/
```

**6.手机号(宽松), 只要是13,14,15,16,17,18,19开头即可**

```
/^1[3-9]\d{9}$/
```

**7.email地址**

```
/^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/
```

**8.国内座机电话,如: 0341-86091234**

```
/\d{3}-\d{8}|\d{4}-\d{7}/
```

**9.二代身份证号(18位数字),最后一位是校验位,可能为数字或字符X**

```
/^\d{6}(18|19|20)\d{2}(0\d|11|12)([0-2]\d|30|31)\d{3}(\d|X|x)$/
```



------

# 移动端

## 好气网本地调试

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_16-19-29.jpg)

- 测试包，开发包 这些，点击这里可以输入你本地地址，进行调试，就不用每次都发版本了
- 要与真机的环境是一个网络
- 模拟器，有些场景有限，最后，还是要跑真机看下
- 输入本地地址即可

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_16-20-44.jpg)

> <font color='gree'>输入本地地址，不是location</font>
>
> <font color='gree'>本地地址查询：ipconfig</font>
>
> ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_16-22-50.jpg)
>
> ![image-20230629162319588](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20230629162319588.png)

------

## 下载文件

```apl
![Snipaste_2023-06-27_10-29-35](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-27_10-29-35.jpg)window.ic.run({
        action: 'system.download',
        params: {
          fileUrl: '',
          fileName: ''
        },
        success: (res) => {
          console.log(res)
        }
      })
    }
```

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-27_10-29-35.jpg)

------

## scss样式

## 设置主轴为纵向

```scss
flex-direction: column;
```

------

## Vant引用

```js
import { NavBar, Loading, Empty, Popup, Calendar, cell, field, button } from 'vant';

export default {
  components: {
    [NavBar.name]: NavBar,
    [Loading.name]: Loading,
    [Empty.name]: Empty,
    [Popup.name]: Popup,
    [Calendar.name]: Calendar,
    [cell.name]: cell,
    [field.name]: field,
    [button.name]: button,
    RoundTabs,
    RoundTab,
  },
  data() {
      ...
  }
}
```

------

## vant框架van-cell插槽无法换行

> [vant框架van-cell插槽无法换行问题及解决](https://www.jb51.net/article/273095.htm)
>
> [**vant框架van-cell插槽无法换行**](https://www.jb51.net/article/273095.htm)

### 解决方法

### label

在插槽中定义div的属性display为block;再在里面定义一个块级标签就行了。

```vue
<template>
<div>
    <van-cell-group v-for="item in list" :key="item.index">
         <van-list v-bind="item" >
              <div style="width: 100%;">
                  <van-cell :title="item.name">
                   <template slot="label">
                      <span>{{item.sex}}</span>
                      <div style="display:block;">
                        <span style="display:block;">{{item.age}}</span>
                      </div>
                    </template>
                  </van-cell>
             </div>
          </van-list>
    </van-cell-group>
    </div>
</template>

<script>
export default {
     data() {
      return {
          list:[
              {
                  name:"张三",
                  sex:"男",
                  age:15
              },
              {
                  name:"李四",
                  sex:"男",
                  age:16
              }
          ]
      }
     }
}
</script>

<style>
</style>
```

效果如下：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-08_11-07-41.png)

### value

```vue
<template>
<div>
    <van-cell-group v-for="item in list" :key="item.index">
         <van-list v-bind="item" >
              <div style="width: 100%;">
                  <van-cell :title="item.name">
                   <template slot="label">
                      <span>{{item.sex}}</span>
                      <div style="display:block;">
                        <span style="display:block;">{{item.age}}</span>
                      </div>
                    </template>
                  </van-cell>
             </div>
          </van-list>
    </van-cell-group>
    </div>
</template>

<script>
export default {
     data() {
      return {
          list:[
              {
                  name:"张三",
                  sex:"男",
                  age:15
              },
              {
                  name:"李四",
                  sex:"男",
                  age:16
              }
          ]
      }
     }
}
</script>

<style>
</style>
```

效果如下：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-08_11-10-13.png)

------



## scroll滚动事件如何监听页面是否滚动到底部

[vue @scroll 监听滚动事件，让你一看就明白](https://blog.csdn.net/weixin_46683341/article/details/119025865)

**监听是否滚动到底部多数应用在加载更多之类的功能。话不多说，直接上菜。**

考虑vue渲染规则 需要在元素渲染后执行scroll监听 否则获取不到对应dom节点
所以需要配合使用 $nextTick()

cont是监听区域，‘scroll’是添加事件，this.scroll是方法，div绑定ref="cont"。

```js
mounted() {
    this.$nextTick(()=>{
        this.$refs.cont.addEventListener('scroll',this.scroll)
    })
}
```

scroll判断是否到底部，如果到底了就可以请求数据或者其它操作。

```js
scroll(e) {
            let scrollTop = e.target.scrollTop; //滑入屏幕滚动条滚动时，距离顶部的距离
            let windowHeitht = e.target.clientHeight; //能看到的页面的高度
            let scrollHeight = e.target.scrollHeight; //监控的整个div的高度（包括现在看到的和上下隐藏起来看不到的）
            let total = scrollTop + windowHeitht
            if(total == scrollHeight){
                console.log("到底了")
                //加载操作
            }else {
                console.log("还没有到底")
            } 
        }
```

如果没有要加载数据了，就可以把scroll事件移除了，以免浪费性能。

```js
this.$refs.cont.removeEventListener('scroll',this.scroll)
```

<font color='gree'>**注意：**一定给滚动的区域加高度和超出部分为滚动，不然不会触发事件。滚动区域class= "cont"。</font>

```js
.cont {
    overflow: scroll;
    width: 100%;
    height: 677px;
}
```

### 案例1

> <font color='gree'>该案例有细微问题，详细看<彻底搞懂clientHeight、offsetHeight、scrollHeight的区别></font>
>
> offsetHeight是一个整数，所以如果有的机型会出现小数的情况下，会有误差导致滚动不触发
>
> 所以将e.target.scrollTop + e.target.offsetHeight >= e.target.scrollHeight
>
> 改为e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight)

```js
// 盒子
<div class="scroll-box" @scroll="scrollEvent($event)">
    ...
<div>

//元素的滚动事件
    scrollEvent(e) {
      // if (e.target.scrollTop + e.target.offsetHeight >= e.target.scrollHeight) {
      if (e.target.scrollHeight - (e.target.scrollTop + e.target.offsetHeight)) {
        //当前内容至顶部+屏幕高是否大于显示内容高
        console.log('来看看触底了没');
        if (this.currentPage >= this.totalpage) {
          //如果当前页等于总页数 隐藏加载组件
          this.showloading = false;
          return;
        } else {
          //否则显示加载组件
          this.showloading = true;
        }
        if (this.showloading) {
          //如果是加载中
          this.currentPage++; //当前页加1
          this.init();
        }
      }
    },
```

### 案例2

做首页按需加载的时候 滚动条滚动到底部之后加载或者一个移动端出现一个弹框滑动到底部触发事件

#### ①在元素标签上直接绑定 [scroll](https://so.csdn.net/so/search?q=scroll&spm=1001.2101.3001.7020) 事件

```vue
 <div class="dialogCountent" ref="dialogCountent" @scroll="orderScroll($event)">
     ...
 </div>
```

注意：重点在ref和@scroll上面，后面会用到

#### ②再给这个div一个样式，肯定得有一个高度啥的

```css
 .dialogCountent{
     height: 2.6rem;
     overflow-y: scroll
 }
```

#### 介绍一下三个值：（知道的可以跳过这块）

##### clientHeight：

元素客户区的大小，指的是元素内容及其边框所占据的空间大小（经过实践取出来的大多是视口大小）

例子：可以用公式 CSS height + CSS padding - 水平滚动条的高度 (如果存在) 来计算。

![在这里插入图片描述](https://img-blog.csdnimg.cn/59f9f70a16a840c1b1dc27ec561f9606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4MzM0MQ==,size_16,color_FFFFFF,t_70)

如图，这样一个div，它的clientHeight为95，计算：50(height)+30(padding-top)+30(padding-bottom)-15(经测量滚动条高度就是15)=95

##### scrollHeight：

因为限制了父元素的高度，所以不能全部显示子元素，设置了overflow之后，可以通过滚动条的形式滑动查看子元素。效果如图1，如果没有限制父元素的高度，那么效果将如图2显示。

![在这里插入图片描述](https://img-blog.csdnimg.cn/a52a6dbaa7f94db29514d3b511df734e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY4MzM0MQ==,size_16,color_FFFFFF,t_70)

scrollHeight就是图2的高度，没有高度限制时，能够完全显示子元素时的高度（clientHeight）。 所以这里scrollHeight为220，计算：200+10+10=220

##### scrollTop

设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离

#### ③前面传过来一个然后可以通过$event事件获取scrollTop之类的

定义三个变量用来接收event上三个值。

```js
 scrollGet(e) {
            let scrollHeight = this.$refs.dialogCountent.scrollHeight;
            let clientHeight = this.$refs.dialogCountent.clientHeight;
            let scrollTop = this.$refs.dialogCountent.scrollTop;
            if(scrollHeight - (scrollTop+clientHeight) <= 1 ){
                this.isRead = true; //  这是一个disabled的显示，自己定义的
                this.confirmText = '同意' // 更改一个内容文字
            }
  }
```

------

## vant 框架form表单 validate方法 （vue）

> [Vue vant框架form表单 validate方法](https://blog.csdn.net/weixin_60700622/article/details/121240862)

> <font color='gree'>在vant框架中，由于vant组件的特殊性，可能会出现`this.$refs.form.validate()`不生效的情况。这是因为vant组件中的表单元素并不是原生的`<form>`和`<input>`标签，而是基于`<van-form>`和`<van-field>`组件构建的。因此，我们需要使用vant提供的方法来触发表单验证。</font>
>
> ```vue
> <template>
>   <van-form ref="form" @submit.prevent="submitForm">
>     <van-field v-model="name" label="姓名" rules="required" />
>     <van-field v-model="email" label="邮箱" rules="required,email" />
>     <van-field v-model="phone" label="电话" rules="required,phone" />
>     <van-button type="primary" native-type="submit">提交</van-button>
>   </van-form>
> </template>
> 
> <script>
> export default {
>   data() {
>     return {
>       name: '',
>       email: '',
>       phone: ''
>     };
>   },
>   methods: {
>     validateForm() {
>       return this.$refs.form.validate();
>     },
>     submitForm() {
>       this.validateForm().then((result) => {
>         if (result) {
>           alert('表单数据合法');
>         } else {
>           alert('表单数据不合法');
>         }
>       });
>     }
>   }
> };
> </script>
> ```
>
> <font color='gree'>在这个示例中，我们使用了`<van-form>`和`<van-field>`组件来构建表单，并在`<van-field>`组件中使用`rules`属性设置验证规则。在`validateForm`方法中，我们调用了`this.$refs.form.validate()`方法，并返回一个`Promise`对象，表示表单验证的结果。在`submitForm`方法中，我们首先调用`validateForm`方法进行表单验证，然后根据验证结果弹出相应的提示框。</font>

通过ref可以获取到form实例并调用实例方法 在<van-form></van-form> 上面添加 ref="dataform" 可以获取到表单里的所有元素 因为我要进行表单验证 所以在medthod中通过 然后在我要验证的那个<van-field></van-field> 上面添加name="xxx"    this.$refs.dataform.validate("xxx")。 validate验证表单，支持传入name来验证单个或部分表单项

![img](https://img-blog.csdnimg.cn/bf036f7dcb15488385902c0bd6041c64.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5biM552h5LiN6YaS,size_20,color_FFFFFF,t_70,g_se,x_16)

![img](https://img-blog.csdnimg.cn/5d4519d11a49441683fe976e18f8f3f2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5biM552h5LiN6YaS,size_20,color_FFFFFF,t_70,g_se,x_16)

我在运行的过程中有个报错：Cannot read properties of undefined (reading 'validate')

然后我去搜了一下 总结了几个会报错的原因   1.在组件中ref前面不需要加 ： 2.在校验方法中如果没有传递相关的参数也会报错 就是name是一定要写的！

------

## 清除校验

```apl
this.$refs.ruleForm?.resetValidation();
若不生效，则检查是不是按键没有设置
native-type="button"
如果不设置会默认触发form得验证
```



------

## 彻底搞懂clientHeight、offsetHeight、scrollHeight的区别

[彻底搞懂clientHeight、offsetHeight、scrollHeight的区别](https://baijiahao.baidu.com/s?id=1716515774541606312&wfr=spider&for=pc)

我们开发web代码的时候,经常回遇到各种高度的计算. 因为总是忘记几者之间得区别,每次都要现查,这次通过这篇文章彻底搞明白这几个长度的区别.

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\5bafa40f4bfbfbedc58af5cc59e0993faec31f4f.webp)

在这里插入图片描述

### 1.定义说明

### clientHeight

含义：元素的像素高度，包含元素的高度+内边距，不包含水平滚动条，边框和外边距

### 图示：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\377adab44aed2e73b97be7019b11cf8287d6fa22.webp)

### offsetHeight

含义：元素的像素高度 包含元素的垂直内边距和边框，水平滚动条的高度，<font color='gree'>且是一个整数</font>

### 图示：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\a8014c086e061d95d78cbbb967e464d863d9ca07.webp)

### scrollHeight

含义：元素内容的高度，包括溢出的不可见内容

### 图示：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\d52a2834349b033bf7f0d6f409de58dad539bdb9.webp)

### offsetLeft

含义：返回元素左上角相对于offsetParent的左边界的偏移像素值

### 注意点

1.对块级元素来说，offsetTop、offsetLeft、offsetWidth 及 offsetHeight 描述了元素相对于 offsetParent 的边界框。但是文本框不是如此.文本框的offsetLeft和offsetTop是第一个文本框的左偏移和上偏移.

2.offsetParent元素指改元素的定位元素以及最近的table,td,th,body. 可见，offsetParent和position属性的包含块概念类似.大部分场景下可以通用.

3.offsetTop和offsetLeft都是相对于其内边距边界的.

### offsetLeft和left属性的区别

**1.position为fixed时值不同** 当position为fixed的时候，offsetLeft的值将会是null,而left此时一般有确定的数字值.**2.相对边距不同** offerset的是相对于offsetParent的内边距边界，left是相对于包含块的外边距边界.**3.包含块有区别** offerset相对于定位的祖先元素或者 table/td/th/body等祖先元素,left仅仅是相对于定位祖先元素+body

### clientHeight与offsetHeight的区别

clientHeight仅仅包含内边距+高度，offsetHeight包含内边距+滚动条+边框 所以可以这样说： clientHeight+滚动条高度+边框 = offsetHeight

------

# scss

## 文字内容超出两行时显示省略号

> <font color='gree'>如果出现弹性盒子和其他bug参考下面的注意事项</font>

文字内容时显示省略号

```html
<view class="newsTitle">
	这里是一条很长很长很长的内容
</view>
```

设置内容超出<font color='red'>一行</font>显示省略号的css样式如下：

```js
.newsTitle{
	width: 536rpx;  //设置宽度
    
    white-space: nowrap;	//防止文本换行
  	overflow: hidden;	//隐藏超出父元素宽度的文本
  	text-overflow: ellipsis;	//将超出部分省略，并用省略号表示
}

```

>在上面的代码中，使用 width 属性设置父元素 .container 的宽度，并使用 white-space: nowrap; 防止文本换行。然后使用 overflow: hidden; 隐藏超出父元素宽度的文本，最后使用 text-overflow: ellipsis; 属性将超出部分省略，并用省略号表示。

设置内容超出<font color='red'>多行</font>显示省略号的css样式如下：（<font color='gree'>删除`white-space: nowrap`</font>）

```scss
.newsTitle{
	width: 536rpx;  //设置宽度
    
  	overflow: hidden;	//隐藏超出父元素宽度的文本
  	text-overflow: ellipsis;	//将超出部分省略，并用省略号表示
    
	display: -webkit-box;  //使用自适应布局
	-webkit-line-clamp: 2;  //设置超出行数，要设置超出几行显示省略号就把这里改成几
	-webkit-box-orient: vertical;
}

```

> 1.语法:text-overflow:clip|ellipsis
>
> 默认值:clip;
>
> 适用于:所有元素
>
> clip:当前对象内文本溢出时不显示省略标记(...),而是将溢出部分裁剪。
>
> ellipsis:当对象内文本一处时显示省略标记(...)。
>
> 当然这还是不够的，需要加点调料才能出现效果:
>
> 那就是配合
>
> ```css
> overflow:hidden
> 
> white-space:overflow;
> ```
>
> 2.这时候BT的产品经理来了，小鹏啊~一行省略怎么行，变成三行出现省略。
>
> 处理办法:
>
> 将white-space去除，并且加上:
>
> ```css
> display:-webkit-box;
> 
> -webkit-line-clamp: 3/*第几行裁剪*/
> 
> -webkit-box-orient:vertical;
> ```
>
> -webkit-line-clamp 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。 常见结合属性：
> 2-1.display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
> 2-2.-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。
> 2-3.text-overflow: ellipsis; ，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。

### <font color='gree'>注意事项:</font>

> <font color='red'>显示错误问题</font>
>
> 1. ！！！css样式一定要写在要省略的盒子上即：<font color='gree'>盒子内就是文字，不能再嵌套新块级元素新div！</font>
>
> 2. `br`可以强制换行
>
> 当需要进行如下图式样式：
>
> ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-12-04.jpg)
>
> 可以通过如下代码来显示：
>
> ```vue
> <div class="file-content">
>     {{ fileName }}
>     <br />
>     <span style="font-size: 12px; color: #969799">{{ fileSize }}</span>
>   </div>
> ```
>
> ```scss
> .file-content {
>   width: 100%;  //宽度
>   margin: 0 12px;
>   font-size: 16px;
>     //隐藏代码
>   overflow: hidden;
>   text-overflow: ellipsis;
>   white-space: nowrap;
> }
> ```
>
> `white-space: nowrap;`遇到`br`会换行

><font color='red'>弹性问题</font>
>
>[设置div中文字自适应显示一行，超出则用...代替](https://blog.csdn.net/chaopingyao/article/details/108948002?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168802928416800215098345%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168802928416800215098345&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108948002-null-null.142^v88^control_2,239^v2^insert_chatgpt&utm_term=%E8%AE%BE%E7%BD%AEdiv%E4%B8%AD%E6%96%87%E5%AD%97%E8%87%AA%E9%80%82%E5%BA%94%E6%98%BE%E7%A4%BA%E4%B8%80%E8%A1%8C%EF%BC%8C%E8%B6%85%E5%87%BA%E5%88%99%E7%94%A8...%E4%BB%A3%E6%9B%BF&spm=1018.2226.3001.4187)
>
>完整代码如下所示：
>
>```html
><!DOCTYPE html>
><html lang="en">
><head>
>    <meta charset="UTF-8">
>    <title>将页面平均分成四部分</title>
>    <style type="text/css">
>        *{
>            margin: 0;
>            padding: 0;
>        }
>        .main{
>            width: 100%;
>            height: 100%;
>            position: absolute;
>        }
>        .quarter-div{
>            width: 33%;
>            height: 33%;
>            float: left;
>            /* 强制文字一行内显示 */
>            white-space: nowrap;
>            /* 超出部分隐藏 */
>            overflow: hidden;
>            /* 用省略号替代超出部分 */
>            text-overflow: ellipsis;
>        }
>        .blue{
>            background-color: #5BC0DE;
>        }
>        .green{
>            background-color: #5CB85C;
>        }
>        .orange{
>            background-color: #F0AD4E;
>        }
>    </style>
></head>
><body>
>    <div class="main">
>        <div class="quarter-div blue">你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好</div>
>        <div class="quarter-div green">我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好我很好</div>
>        <div class="quarter-div orange">你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢你呢</div>
>    </div>
></body>
></html>
>```
>
>页面显示如下：
>
>页面显示如下：
>
>![img](https://img-blog.csdnimg.cn/20201007101536453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYW9waW5neWFv,size_16,color_FFFFFF,t_70)
>
>调整浏览器可显示区域的大小，依然可以正常显示：
>
>![img](https://img-blog.csdnimg.cn/20201007102103212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoYW9waW5neWFv,size_16,color_FFFFFF,t_70)
>
>> 参考文献：https://www.jianshu.com/p/8b61786491fc

------

## 垂直居中对齐

>vertical-align法
>
>flex法：使用CSS的flexbox布局：将图片所在的容器设置为display: flex;并使用align-items: center;属性即可。

[vertical-align: middle的用法](https://blog.csdn.net/Efficiency9/article/details/73490326)

在开发前端网页的过程中，水平居中有text-align:center和margin：0 auto。但是垂直居中始终没有一个比较好的解决方案，css中的vertical-align是垂直居中的意思，但是使用起来让人很难以理解 。

vertical-align在css中有着丰富的属性，是我见过为数不多的，今天着重研究vertical-align: middle的用法，其他属性基本与此同理。

><font color='gree'>`vertical-align`该属性只适用于行内元素或表格单元格。对于块级元素，需要将它们设置为`display: inline-block;`或`display: table-cell;`才能使用该属性实现垂直居中。</font>

1. 首先从定义上
   - 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。
   - middle:把此元素放置在父元素的中部。
   - 定义就让人很难以理解，读来读去饶了几遍，但是middle的意思看起来又如此简单。
2. 错误代码

```vue
<div class="big">
    <span class="small">dsada</span>
</div>
<style>
        .big{
            width: 200px;
            height: 200px;
            border: 1px solid #000;
            /*vertical-align: middle;*/
        }
        .small{
            /*vertical-align: middle;*/
            /*display: inline-block;*/
        }
    </style>
```

我首先把vertical-align: middle放到父元素中（text-align:center的用法），然后我放到子元素中（margin:0 auto用法），随后我把span变成行内块级元素，但是结果都没有用。

3. 正确代码

```vue
<div class="big">
    <span class="small">
        <span class="small-two">大声道</span>
        <span class="small-one">之前的</span>
    </span>
</div>
<style>
        .big{
            width: 200px;
            height: 200px;
            border: 1px solid #000;
            /*vertical-align: middle;*/
        }
        .small{
            background-color: #000;
            color: red;
        }
        .small-one{
            line-height: 200px;
        }
        .small-two{
            vertical-align: middle;
        }   
    </style>
```

就是说我们在想让small-two垂直居中时，必须在定义一个同级的行内元素，让目标元素找到基线，这个里面的middle可能相比line-height看不出效果，如果换成bottom、text-top等就看一看出很明显的效果。

4. <font color='gree'>如何让图片垂直居中</font>

```vue
<div class="big">
    <span class="small">
        <img src="http://image.zhangxinxu.com/image/study/s/s128/mm10.jpg" height="200" width="200"/>
        <span class="text">打我手机看山东</span>
    </span>
</div>
<style>
        .big{
            width: 500px;
            height: 400px;
            background-color: yellow;
            margin: 500px auto;
        }
        .small{
            font-size: 18px;
            background-color: #000;
            color: #ffffff;
        }
        img{
            vertical-align: middle;
        }
        .text{
            background: green;
            width: 200px;
            margin-left: 20px;
            line-height: 400px;
        }
    </style>

-------------------------------另一个例子
<template>
  <div>
    <span>
      <img
        width="18px"
        height="18px"
        src="@/assets/imager/download.png"
        alt="mileage"
        style="vertical-align: middle"/>
    </span>
    <span style="vertical-align: middle">{{ ' 附件点击可下载' }}</span>
  </div>
</template>
```

flex法：

```vue
<template>
  <div class="file-card">
    <div class="left-icon">
      <img
        width="38px"
        height="38px"
        :src="fileImgSrc"
        alt="mileage"
        @click="ImagePreview(fileImgSrc)" />
    </div>
    <div class="file-content">
      {{ fileName }}
      <br />
      <span style="font-size: 12px; color: #969799">{{ fileSize }}</span>
    </div>
    <div @click="file = []" class="right-icon">
      <img width="22px" height="22px" src="@/assets/imager/dele-icon.png" alt="mileage" />
    </div>
  </div>
</template>

<style lang="scss" scoped>
.file-card {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 16px;
  margin: 20px 16px 0;
  background: #f2f4f8;
  border-radius: 8px;

  .file-content {
    width: 100%;
    margin: 0 12px;
    overflow: hidden;
    font-size: 16px;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .left-icon,
  .right-icon {
    display: flex;       // 这里
    align-items: center; 	// 这里
  }
}
</style>
```



------

## div 英文和数字不自动折行 文字换行

[文字换行 word-wrap word-break](https://blog.csdn.net/glorydx/article/details/112671300)

前端渲染文字是最常见的应用场景，可有的时候，要求能够识别[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)中的换行。

后端出来的数据可能是这样的，中间有一个回车符号，要求前端能够换行显示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115153317537.png)
如果不处理的话
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210115153425226.png)
是没办法识别回车符号的，无法正确显示。

对于前端来说，用css来控制是最简单的方式。

```scss
.scf-textarea-text {
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-all;
}
```

**white-space** 用来控制文本字符串类的空白和换行

```scss
normal：忽略多余的空白，只保留一个空白（默认）；
pre：保留空白(行为方式类似于html中的pre标签)；
nowrap：只保留一个空白，文本不会换行，会在在同一行上继续，直到遇到br标签为止。
pre-wrap：保留空白符序列，正常地进行换行；
pre-line：合并空白符序列，保留换行符；
inherit：从父元素继承white-space属性的值。
```

**word-wrap** 一般使用 break-word

```scss
normal	只在允许的断字点换行（浏览器保持默认处理）。
break-word	在长单词或 URL 地址内部进行换行。
```

**word-break** 一般都是用 break-all

```scss
normal	使用浏览器默认的换行规则。
break-all	允许在单词内换行。
keep-all	只能在半角空格或连字符处换行。
```

**word-warp: break-word 和 word-break:break-all 的区别**
如果两个属性都没有
图1

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/5446e4b2eae0f40605a56ecaf082f633.png#pic_center)

如果只有 word-warp: break-word ，当单词太长时，单词太长的部分会换到下一行。
图2
![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/a9107948ee5dd93934138face6fce65f.png#pic_center)
如果还有 word-break:break-all
图3

![在这里插入图片描述](https://img-blog.csdnimg.cn/img_convert/1682eec33bce59d22187eb22e190e4a0.png#pic_center)

结论：

很显然，这两个看似相同的属性，其实作用完全不同。

word-warp: break-word 是将一个单词超出的部分换到下一行。
word-break:break-all 的作用是 如果一个单词太长，那一行剩余空间放不下，单词也不会另起一行开始渲染。

因为浏览器默认的情况是 word-break:normal
如果一行文本中，剩余的空间无法容纳接下来的一个单词，那么那个单词就会在另一行开始渲染第一个字母。就会出现图2的情况

------

## box-sizing:border-box的理解和作用

> [引用](https://blog.csdn.net/qq_51066068/article/details/127048560)

>[盒子模型](https://so.csdn.net/so/search?q=盒子模型&spm=1001.2101.3001.7020)
>
>**盒子模型是指：外边距（margin）+ border（边框） + 内边距（padding）+ content（内容）**
>
>可以把每一个容器，比如div，都看做是一个盒子模型
>
>比如你给一个div设置宽高为500px，但实际你设置的只是content，之后你又设置了padding:10px;border:1px solid red;
>
>这时div的宽高就会变为544px（content 500px + padding 40px + border 4px）
>
>**相当于一个元素的实际宽高是由：　padding + border + content 组成**
>
>**1、没有设置box-sizing:border-box属性，**宽高会加上padding和border的值，需要我们手动去计算，减去padding和border的值，并调整content的值，以免超过给定的宽高
>
><font color='gree'>**比如下图，我给父元素parent设置宽高为500px，背景色为黑色；然后给子元素设置宽高为478px，并设置内边距10px,红色边框1px，背景颜色为灰色**</font>
>
><font color='gree'>**此时子元素的宽高为500px（content 478px + padding 40px + border 4px）所以就覆盖了父元素的黑色背景，只能看到子元素的灰色背景**</font>
>
>**2、加了box-sizing:border-box属性**，<font color='gree'>**padding和border的值就不会在影响元素的宽高，相当于把padding和border的值都算在content里**</font>
>
>盒子模型会自动根据padding和border的值来调整content的值，就不需要手动调整
>
>**标准盒子模型，一般浏览器也都默认为标准盒子模型。即：box-sizing:content-box**
>
>**怪异盒子模型，一般根据实际项目需要自行设置。即：box-sizing:border-box**



------



## 一个盒子内进行两行排列，同时实现居中，支持一个或两个行

![image-20230420154627661](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20230420154627661.png)

```vue
<a-col :span="7">
    <div class="information-place">
		{{ order.receiptAddress || '-' }}
		<template v-if="order.receiptAddrDetail">
			<!-- br用于换行，放在template内来 -->
			<br />
			{{ order.receiptAddrDetail || '-' }}
		</template>
	</div>
</a-col>

-----------
<style lang="scss" scoped>
.information-place {
      display: flex;
      align-items: center;     //
      justify-content: center;
      height: 80px;
      line-height: normal;
    }
</style>
```

## CSS justify-content 属性

div {    display: flex;    justify-content: space-around; }

```js
/* 对齐方式 */
justify-content: center;     /* 居中排列 */
justify-content: start;      /* 从行首开始排列 */
justify-content: end;        /* 从行尾开始排列 */
justify-content: flex-start; /* 从行首起始位置开始排列 */
justify-content: flex-end;   /* 从行尾位置开始排列 */
justify-content: left;       /* 一个挨一个在对齐容器得左边缘 */
justify-content: right;      /* 元素以容器右边缘为基准，一个挨着一个对齐, */

/* 基线对齐 */
justify-content: baseline;
justify-content: first baseline;
justify-content: last baseline;

/* 分配弹性元素方式 */
justify-content: space-between;  /* 均匀排列每个元素
                                   首个元素放置于起点，末尾元素放置于终点 */
justify-content: space-around;  /* 均匀排列每个元素
                                   每个元素周围分配相同的空间 */
justify-content: space-evenly;  /* 均匀排列每个元素
                                   每个元素之间的间隔相等 */
justify-content: stretch;       /* 均匀排列每个元素
                                   'auto'-sized 的元素会被拉伸以适应容器的大小 */

/* 溢出对齐方式 */
justify-content: safe center;
justify-content: unsafe center;

/* 全局值 */
justify-content: inherit;
justify-content: initial;
justify-content: unset;
```

| 值            | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| flex-start    | 默认值。从行首起始位置开始排列。                             |
| flex-end      | 从行尾位置开始排列。                                         |
| center        | 居中排列。                                                   |
| space-between | 均匀排列每个元素，首个元素放置于起点，末尾元素放置于终点。   |
| space-evenly  | 均匀排列每个元素，每个元素之间的间隔相等。                   |
| space-around  | 均匀排列每个元素，每个元素周围分配相同的空间。               |
| initial       | 设置该属性为它的默认值。请参阅 [*initial*](https://www.runoob.com/cssref/css-initial.html)。 |
| inherit       | 从父元素继承该属性。请参阅 [*inherit*](https://www.runoob.com/cssref/css-inherit.html)。 |



[引用](https://www.jianshu.com/p/61dab77537f0)

```html
.ulist {
            width: 500px;
            height: 300px;
            border: 1px solid #000;
            display: flex;
            /* 两端对齐，项目之间的间隔都相等 */
            justify-content: space-between;
            /* 每个项目两侧间隔相等，项目之间间隔比项目与边框的间隔大一倍
 */
            /* justify-content: space-around; */
            /* 每个项目两侧间隔相等，项目之间间隔比项目与边框的间隔相等
 */
            /* justify-content: space-evenly; */
            /*允许换行*/
            flex-wrap: wrap;
        }
        
        .ulist>li {
            width: 100px;
            height: 100px;
            border: 1px solid #000;
        }

    <ul class="ulist">
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
        <li>6</li>
        <li>7</li>
        <li>8</li>
    </ul>
```

##### 运行结果

![img](https://upload-images.jianshu.io/upload_images/25154103-c48bd8706fda96d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/525/format/webp)

如果格子未铺满，就会出现第二行的格子向两端对齐

![img](https://upload-images.jianshu.io/upload_images/25154103-771ac2906ee34eec.png?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp)

期望的结果

![img](https://upload-images.jianshu.io/upload_images/25154103-32c5985d7d932eed.png?imageMogr2/auto-orient/strip|imageView2/2/w/510/format/webp)

> 给ulist添加一个伪元素

```
.ulist:after {
            content: "";
            flex: 0 0 233px;
          /* 如何计算233
                ulist的width是500px，li的width是100px ，根据运行结果，每一行有四个格子，三个间隔，500-100-100-33-33=244，有一点小误差调一调就差不多了
             */
        }
```

........

------

## calc(100% - 20px); 使用问题

CSS3中width属性的width: calc(100% - 20px); 使用问题

**目的是动态改变宽度/高度的变化，适配问题。**

width: calc(100% - 20px); 

css3 的 calc()函数。

这里的意思是设置宽度比100%的宽度少20px。

calc()函数用于动态计算长度值。 calc()函数支持 "+", "-", "*", "/" 运算；

calc()函数使用标准的数学运算优先级规则；

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2ktYmV0YS8xNzQ1MzEyLzIwMTkxMi8xNzQ1MzEyLTIwMTkxMjE0MTUxMjAyNTE2LTE2NDA3MDYyNDUucG5n?x-oss-process=image/format,png)

------

## :class =“[]/{}“样式绑定

[样式绑定：class =“[]/{}“](https://blog.csdn.net/binbinhxx/article/details/112343598)

[（14）:class用法](https://blog.csdn.net/w_t_y_y/article/details/106198191)

#### 样式绑定

对于一个相对美观的网站肯定离不开样式操作，[Vue](https://so.csdn.net/so/search?q=Vue&spm=1001.2101.3001.7020)也提供了相关的样式处理，样式处无非是两种方式，一种是通过类名class来影响标签的样式，另外一种是直接操作标签的style属性从而定义标签的内部样式。这两种方式vue都支持。

1. class样式处理

> className可以加上''，也可以不加引号。 加""来解决有-的命名
>
> ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-05-04_17-08-54.png)

- 对象语法

```js
:class = "{className1:(条件1),className2:(条件2)}"
```

- 数组语法

```js
:class = "[activeClass,errorClass]"
```

- 复杂的语法

```scss
:class="`className ${{ '01': 'wait', '02': 'deal', '03': 'cancel' }[item.status]}`"

或者
:class="releaseDate ? `date black` : `date gray `"
```

```scss
.status {
          height: 20px;
          padding: 0 6px;
          font-size: 10px;
          line-height: 20px;
          border-radius: 4px;

          &.wait {
            color: #f09918;
            background: #faf5e4;
          }

          &.progress {
            color: #0473ff;
            background: #e5f1ff;
          }

          &.deal {
            color: #16b57d;
            background: #e1f5ea;
          }

          &.cancel {
            color: #737782;
            background: #f2f4f8;
          }
        }
```

例子：

```apl
<div :class="`status ${{ '01': 'wait', '02': 'deal', '03': 'cancel' }[item.status]}`">

.status {
          height: 20px;
          padding: 0 6px;
          font-size: 10px;
          line-height: 20px;
          border-radius: 4px;

          &.wait {
            color: #f09918;
            background: #faf5e4;
          }

          &.progress {
            color: #0473ff;
            background: #e5f1ff;
          }

          &.deal {
            color: #16b57d;
            background: #e1f5ea;
          }

          &.cancel {
            color: #737782;
            background: #f2f4f8;
          }
        }
```



```html
    <style type = "text/css">
        .active{
            border:1px solid red;
            width:100px;
            height:100px;
        }  
        .error {
            background-color: orange;
        }  
    </style>
<body>
    <div id = "app">
        <!-- 有时候希望样式被动态的控制 -->
        <!-- 类名以一个对象的方式 对象里面可以包含键值对-->
        <!-- 键值对的左边是类名 右边需要提供属性来控制类名是否显示-->
        <!-- 一般类名对应的属性是以is开头，作为标志位，要么truth要么false-->

        <div v-bind:class="{active: isActive,error: isError}">测试样式</div>
        <button v-on:click = "handle">切换</button>
    </div>
    <script src="vue.js"></script>
    <script>
        /*样式绑定*/
        var vm = new Vue({
            el:'#app',
            data: {
                isActive: true,
                isError:true
            },
            methods: {
                handle:function(){
                    // 控制isActive的值在true和false之间进行切换
                    this.isActive = !this.isActive;
                    this.isError = !this.isError;
                }
            }
        }) 
    </script>
</body>
```

**样式的动态处理**实际上就是控制类名是否添加到便签里面。
通过**v-bind绑定class属**性，它的值通过对象的方式，可以控制类名是否显示，如果后面的值是truth那类名就是显示的，如果是false那就是不显示。要想控制多个类名就在对象里边用，**逗号**分开，添加多个**键值对**。

- **数组语法**

```html
    <style type = "text/css">
        .active{
            border:1px solid red;
            width:100px;
            height:100px;
        }  
        .error {
            background-color: orange;
        }  
    </style>
</head>
<body>
    <div id = "app">
        <!-- 有时候希望样式被动态的控制 -->
        <!-- 类名以一个对象的方式 对象里面可以包含键值对-->
        <!-- 键值对的左边是类名 右边需要提供属性来控制类名是否显示-->
        <!-- 一般类名对应的属性是以is开头，作为标志位，要么truth要么false-->

        <div v-bind:class="[activeClass,errorClass]">测试样式</div>
        <button v-on:click = "handle">切换</button> 
    </div>
    <script src="vue.js"></script>
    <script>
        /*样式绑定*/
        var vm = new Vue({
            el:'#app',
            data: {
                activeClass:'active',
                errorClass:'error'
            },
            methods: {
                handle:function(){
                    // 控制isActive的值在true和false之间进行切换
                    this.activeClass = "";
                    this.errorClass = "";
                }
            }
        }) 
    </script>
</body>
```

class样式处理数组语法中直接需要定义相关的属性，属性的值表示的是实例的类名，要想加多个类名的话就往数组里面加多个这样子的属性，他们的值都会作为最终的类名渲染到便签的class属性当中。

------

## vue中css变量的使用

[css变量的使用方法](https://blog.csdn.net/qq_41636947/article/details/121383003)

[vue中css变量的使用](https://blog.csdn.net/weixin_53474595/article/details/128220347)

### CSS变量的使用方法

```
在css中，变量是一种特殊的样式，可以在css中设置一个变量，之后，就可以在子元素中获取到这个值。
```

### 1、在css中使用变量

```js
1、css中声明变量

--color：red

2、使用变量

color:var(--color)  //color:red获取到全局声明变量值为red
```

### 2、使用vue中的变量

（1）、在htm标签中

```vue
<span :style="{'--color':变量color}" ref='devcolor' />

data中声明变量color

data(){

retrun {

color:red}}

或者使用this.$refs.devcolor.style.setProperty('--color',this.color)
```

（2）、css中使用color变量

```js
color:var(--color)  //使用变量color：red
```

示例如下：

![c8e70436729545a9a5ead9ba9854852f.png](https://img-blog.csdnimg.cn/c8e70436729545a9a5ead9ba9854852f.png)

![f75780ef77254a3ea802d096256cd744.png](https://img-blog.csdnimg.cn/f75780ef77254a3ea802d096256cd744.png)



```scss

.root {
  --color: red;
}
.son {
  color: var(--color);
}

```

```
以上的代码，就是在root中定义了一个变量，变量名为--color，变量值为red。
在子元素中，可以通过var(--color)来获取这个变量的值。
```

### 3. CSS变量的用途

#### 方便的管理统一的属性

这应该是最优先想到的用途了
当一些元素拥有大部分相同的值时，使用CSS变量来使其便于维护

```css
.root {
    --color: red;
}
.son1 {
  color: var(--color);
}
.son2 {
  color: var(--color);
}

```

#### JS统一控制

使用js可以方便的获取到元素上到css变量的值，并且可以统一控制。

```js
// 获取一个 Dom 节点上的 CSS 变量
element.style.getPropertyValue("--my-var");

// 获取任意 Dom 节点上的 CSS 变量
getComputedStyle(element).getPropertyValue("--my-var");

// 修改一个 Dom 节点上的 CSS 变量
element.style.setProperty("--my-var", jsVar + 4);
```

#### 使用CSS变量的示例

当我们需要实现一个元素的样式随着滚动改变时，有时会使用JS即时计算，然后逐个改变元素的样式。
这样对于性能的消耗是非常大的。
现在，我们使用CSS变量来实现，当页面滚动时，我们只改变CSS变量的值，然后在CSS中用CSS变量来计算样式。

```js
let navScale = 0;
let scrollProcess=document.body.scrollTop + window.innerHeight;
navScale = ( scrollProcess - this.outer_Start_Height ) /  window.innerHeight;
// 把navScale限制在0-1内
navScale = Math.min(this.max, Math.max(0, navScale));
this.$refs.stickyouter.style.setProperty('--scroll-height',navScale)
```

以上代码，改变了–scroll-height的CSS变量，他会在0-1之间
然后，我们在CSS中使用他

```css
.sticky1{
    opacity: var(--scroll-height);
}
.sticky2{
    transform: translateX(calc(1000px - calc(var(--scroll-height) * 1000px)));
}
```

我们还可以通过计算来适应到不同的属性中。比如上面的代码中的transform

calc使用方法见 https://blog.csdn.net/qq_41636947/article/details/121459411

### 4、项目案例

```vue
<template>
  <div :class="{ 'squre-container': ifUnloading === '01' }">
   <van-popup
      class="pop-height"
      :style="{ '--height': topSafeHeight }">
      <div class="search-list-container">
     	...
      </div>
    </van-popup>
  </div>
</template>
<script>
export default {
	data() {
    	return {
      		topSafeHeight: this.$nativeSafeArea.topSafeHeight + 'px', //头部安全距离
    };
  },
}
</script>
<style lang="scss">
.pop-height {
  height: calc(100% - var(--height));
}
</style>
```

------

## 1x，2x，3x切图是如何适配的

作为设计师和前端开发人员，默认在将设计稿交付开发时，需提供多倍率的切图，那究竟为什么需要多倍率切图呢？今天我终于搞清楚啦～



Q:什么是切图？

A:切图是设计稿中无法用代码实现的，比如图标、广告图，需要提供图片给开发人员。

Q:屏幕尺寸、物理分辨率、像素密度分别是什么？

A:要了解切图适配，首先需要知道3个概念。

（1）屏幕尺寸：屏幕对角线长度

（2）分辨率：屏幕像素点总数，即横向的像素点数*竖向的像素点数

（3）像素密度（PPI）：每英寸的像素点数，因此PPI数值越高，越能体现出图的细节

![![img](https://pic3.zhimg.com/80/v2-5acbb82d79501cdb1fd58d7c62785ba2_1440w.webp](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-20-42.jpg)

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-21-08.jpg)

> 图1 屏幕尺寸、物理分辨率、像素密度示意图（以方块来模拟像素点）



Q:逻辑分辨率是什么？如果没有逻辑分辨率会怎样？

A:如图2，屏幕尺寸一致，像素密度相差1倍。

相同的图片占据屏幕的像素点数量一致，所以在右侧屏幕的显示面积仅占1/4。

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-21-45.jpg)

> 图2 逻辑分辨率示意图

屏幕尺寸和分辨率是固定的，因此要让同一个软件在多设备上显示正常，需要将屏幕的物理分辨率进行转换，不管实际有多少像素点，系统只认准一个分辨率，也就是逻辑分辨率。



Q:不同倍率的切图如何适配设备？

A:逻辑分辨率是系统设定的，用物理分辨率/逻辑分辨率得到倍率的转换值，从而得到缩放因子，再根据缩放因子决定该设备使用的切图。

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-22-13.jpg)

> 表1 不同设备的倍率换算



Q:用错切图会导致什么问题？

A:我们以极小的圆形切图做一个示例。

在高分辨率的设备上使用@1x切图，看到切图明显有锯齿感，严重了会影响切图形状的识别。

在低分辨率的设备上使用@3x切图，调整切图的尺寸后视觉上与原本切图效果基本一致。

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-06-29_17-22-37.jpg)

> 图3 用错切图示意图

因此会有比较偷懒的做法是直接使用@3x切图，在代码中设置切图的大小，基本不会影响显示的效果。但是这涉及到图片资源的加载和换算，对页面的加载速率有所影响，所以实际开发中还是应该提供不同倍率的切图，根据设备进行适配。

------

# Jenkins

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-04-04_16-57-56.png)

查看最近一次发版

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-04-04_16-59-16.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-04-04_16-59-33.png)

> <font color='gree'>查看发布版本的分支，是否与自己冲突</font>
>
> 如果发布不同分支会覆盖上一发布的分支，所以如果上一版发布分支与自己的不同，应经过商议后新建一共用分支发版

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-04-04_17-00-24.png)

发版

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-04-04_17-03-06.png)

------

# git

看不到远程仓库的某些分支

```
git fetch
一下
```

删除本地分支：

```git
git branch -d 分支名（remotes/origin/分支名）
```

强制删本地：

```
git branch -D 分支名
```

删除远程分支：

```
git push origin --delete 分支名（remotes/origin/分支名）
```



利用命令行删除 git 本地仓库

在此文件夹下，右键打开 `git bash here`，输入命令

```c
find . -name ".git" | xargs rm -Rf
```

 查看远程仓库中所有的分支

```
git remote show 远程仓库名
例如：
git remote show origin
```

查看本地分支

```
git branch 
```

push和fetch的地址

```
git remote -v
```

------

## Commitlint 使用总结

[引用](https://blog.csdn.net/qq_38290251/article/details/111646491)

### 1、Commitlint 是什么

 在多人协作的背景下，git 仓库和 workflow 的作用很重要。而对于 [commit](https://so.csdn.net/so/search?q=commit&spm=1001.2101.3001.7020) 提交的信息说明存在一定规范，现使用 commitlint + husky 规范 `git commit -m ""` 中的描述信息。

一句话说，当我们运行 `git commmit -m 'xxx'` 时，用来**检查 `xxx` 是否满足固定格式的工具。**

### 2、为什么使用 commitlint?

>我们都知道，在使用 git commit 时，git 会提示我们填入此次提交的信息。

> 可不要小看了这些 commit，团队中规范了 commit 可以更清晰的查看每一次代码提交记录，还可以根据自定义的规则，自动生成 changeLog 文件。

### 3、安装

- commitlint: 安装，制定提交规范（采用默认）

>
> npm install --save-dev @commitlint/config-conventional @commitlint/cli

-  生成配置文件commitlint.config.js，当然也可以是 **.commitlintrc.js**

> echo "module.exports = {extends: ['@commitlint/config-conventional']};" > commitlint.config.js

- husky: 还要为 git 配置 husky ，**对 git 的 commit 操作进行校验**。husky继承了Git下所有的钩子，在触发钩子的时候，husky可以阻止不合法的commit，push等等

> npm install husky --save-dev

- 在 package.json 中引入 husky

```js
// package.json
{
  ...
  ...
  "husky": {
    "hooks": {
      "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"
    }  
  }
}
```

这段配置告诉了git hooks，当我们在当前项目中执行 git commit -m '测试提交' 时将触发commit-msg事件钩子并通知husky，从而执行 commitlint -E HUSKY_GIT_PARAMS命令，也就是我们刚开始安装的./node_modules/.bin/commitlint，它将读取commitlint.config.js配置规则并对我们刚刚提交的测试提交这串文字进行校验，若校验不通过，则在终端输出错误，commit终止。

### **4、Commitlint 提交规范**

commitlint 推荐我们使用 config-conventional 配置去写 commit

- 提交格式**（注意冒号后面有空格）**

> git commit -m <type>[optional scope]: <description>

>type ：用于表明我们这次提交的改动类型，是新增了功能？还是修改了测试代码？又或者是更新了文档？ 
>
>optional scope：一个可选的修改范围。用于标识此次提交主要涉及到代码中哪个模块。
>
>description：一句话描述此次提交的主要内容，做到言简意赅。

- 常用的 type 类型

| 类型                          | 描述                                                   |
| ----------------------------- | ------------------------------------------------------ |
| build                         | 编译相关的修改，例如发布版本、对项目构建或者依赖的改动 |
| chore                         | 其他修改, 比如改变构建流程、或者增加依赖库、工具等     |
| ci                            | 持续集成修改                                           |
| docs                          | 文档修改                                               |
| <font color='red'>feat</font> | <font color='red'>新特性、新功能</font>                |
| <font color='red'>fix</font>  | <font color='red'>修改bug</font>                       |
| <font color='red'>perf</font> | <font color='red'>优化相关，比如提升性能、体验</font>  |
| refactor                      | 代码重构                                               |
| revert                        | 回滚到上一个版本                                       |
| style                         | 代码格式修改, 注意不是 css 修改                        |
| test                          | 测试用例修改                                           |

- 例子

```apl
git commit -m 'fix(account): 修复xxx的bug'
git commit -m 'refactor: 重构整个项目'
```

### 5、初始化@commitlint/cli的配置文件

在项目根目录创建名为commitlint.config.js的文件，代码如下：

```js
/**
* feature：新功能
* update：更新某功能
* fixbug：修补某功能的bug
* refactor：重构某个功能
* optimize: 优化构建工具或运行时性能
* style：仅样式改动
* docs：仅文档新增/改动
* chore：构建过程或辅助工具的变动
*/
module.exports = {
  extends: [
    '@commitlint/config-conventional'
  ],
  rules: {
    'type-enum': [2, 'always', [
      'feature', 'update', 'fixbug', 'refactor', 'optimize', 'style', 'docs', 'chore'
    ]],
    'type-case': [0],
    'type-empty': [0],
    'scope-empty': [0],
    'scope-case': [0],
    'subject-full-stop': [0, 'never'],
    'subject-case': [0, 'never'],
    'header-max-length': [0, 'always', 72]
  }
};
// 这些配置是什么意思？请自行查阅commitlint文档
```

### 6、总结

使用 commitlint 可以规范我们每一次的 commit，我们可以用来自动生成 changeLog 等文件，方便代码管理。

具体可学习以下链接： 

[前端codeLint-- 为项目集成ESLint、StyleLint、commitLint实战和原理](https://zhuanlan.zhihu.com/p/100427908)

------

## vscode

1. Commit只会记录您在本地计算机上所做的更改。它不会标记远程存储库中的更改。
2. Commit和Push将执行上述操作并将其推送到远程存储库。这意味着您所做的任何更改也将保存到远程存储库中。
3. 提交和同步做三件事。首先，它会提交本地仓库。其次，它将执行拉动`fetch + merge 或 fetch + rebase`（从远程仓库获取更新的信息）。最后，它会推动`push`。

> 所以是不是可以这样理解：在本地仓库为空的情况下，首次用git pull从远程仓库将最新内容拉到本地仓库&工作区，在工作区更新代码后通过add和commit提交到本地仓库，再次用git fetch+git merge将最新远程仓库内容拉取到本地仓库（可能远程仓库有更新），解决冲突后再git push到远程仓库



## 合并代码

```js
# 1.切换到一个分支以main分支为例
git checkout main
# 2.在main分支上运行git merge命令，将login分支的代码合并到main分支
git merge login
```

```
git checkout master # 切换本地分支为master

git pull  # 更新本地分支master代码为远程最新代码

git checkout [自己的分支名]  # 切换到自己的分支

git merge master  # 合并master到自己的分支

git push # 提送自己本地分支到自己的远程分支
```

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-02-16_15-58-20.png)

处理冲突：

![在这里插入图片描述](https://img-blog.csdnimg.cn/488fd9c7fc1e4cee9adba6c47ff010c7.png)

暂存 提交 完事

#### 分支合并

![在这里插入图片描述](https://img-blog.csdnimg.cn/49944239918c4fd095cd94602f8b9179.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/f1d073f098714753ab2290c31f423113.png#pic_center)
选择要合并到当前分支的其他分支
![在这里插入图片描述](https://img-blog.csdnimg.cn/fc602ff89de5402394a4223bc46494ff.png#pic_center)

------

# axios

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\DFC122C6-C33F-44fb-B9D3-558C348007BF.png)

> 传参可以使用params和query两种方式。
>
> `params`提供`query`参数也会挂载到网址`url`上，data则是body参数不会挂载到`url`上



## mockjs 组件假数据

[引用](https://blog.csdn.net/qsj0606/article/details/124587940)

### 关于[mock](https://so.csdn.net/so/search?q=mock&spm=1001.2101.3001.7020).js，官网描述

```javascript
1.前后端分离
2.不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据
3.数据类型丰富
4.通过随机数据，模拟各种场景
1234
```

### 1、安装mockjs

```javascript
npm install mockjs
//或 在开发环境中引入
npm install mockjs --save-dev
123
```

### 2、创建mock.js文件

1. 在src路径下创建mock.js文件
2. 在main.js引入mock.js文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020103114360435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

### 3、mock.js使用

1.在刚刚创建的mock.js文件中写入测试代码

```javascript
//引入mockjs
const Mock = require('mockjs')   //安装的mockjs，并不是创建的mock.js
// 获取 mock.Random 对象
const Random = Mock.Random;
//使用mockjs模拟数据
Mock.mock('/api/data', (req, res) => {//当post或get请求到/api/data路由时Mock会拦截请求并返回上面的数据
    let list = [];
    for(let i = 0; i < 30; i++) {
        let listObject = {
            title: Random.csentence(5, 10),//随机生成一段中文文本。
            company: Random.csentence(5, 10),
            attention_degree: Random.integer(100, 9999),//返回一个随机的整数。
            photo: Random.image('114x83', '#00405d', '#FFF', 'Mock.js')
        }
        list.push(listObject);
    }
    return {
        data: list
    }
})
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143744782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

2.在xxx.vue文件中使用axios获取mock.js中的随机数据

```javascript
import axios from 'axios'

export default {
      data() {
        return {
          data:[]
        }
      },
      mounted:function() {
        axios.get('/api/data').then(res => {//get()中的参数要与mock.js文件中的Mock.mock()配置的路由保持一致
          this.data = res.data.data;
          console.log(res.data);//在console中看到数据
        }).catch(res => {
          alert('wrong');
        })
      },
      methods:{
          
      }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143825963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

< template >< /template >结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143857263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

效果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143922115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)



------

# vue表单验证rules以及validator验证器的使用

[原文链接](https://blog.csdn.net/m0_53206841/article/details/124337487)

为防止用户犯错，尽可能更早地发现并纠正错误。

Element中Form （表单）组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。

注意：prop对应表单域 model 字段，使用 validate方法时，该属性是必填的。

## 表单验证rules

以官网给出的例子分析来看

`将prop` 属性设置为需校验的字段名。

![img](https://img-blog.csdnimg.cn/6544acebc1994615a345be53ea2a1e6d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_20,color_FFFFFF,t_70,g_se,x_16)

在data里配置要校验字段和校验规则：

required:true表示为必须输入；

message:""设置不符合校验规则时的提示信息；

trigger:""设置校验的触发方式：

​    ‘change’:数据改变时*触发；*

​    ‘blur’:[失去焦点](https://so.csdn.net/so/search?q=失去焦点&spm=1001.2101.3001.7020)时*触发；*

​    没有进行任何输入时,不会*触发*change,但一定会*触发*blur事件。

![img](https://img-blog.csdnimg.cn/a94bad6f8cd14bf89297fe1b05023dc5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_17,color_FFFFFF,t_70,g_se,x_16)

设置校验规则后，表头会出现红色*样式

![img](https://img-blog.csdnimg.cn/4bc5cc0605084e609569f96384284ef5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_12,color_FFFFFF,t_70,g_se,x_16)

该示例完整代码：

```js
<el-form :model="ruleForm" :rules="rules" ref="ruleForm" label-width="100px" class="demo-ruleForm">
  <el-form-item label="活动名称" prop="name">
    <el-input v-model="ruleForm.name"></el-input>
  </el-form-item>
  <el-form-item label="活动区域" prop="region">
    <el-select v-model="ruleForm.region" placeholder="请选择活动区域">
      <el-option label="区域一" value="shanghai"></el-option>
      <el-option label="区域二" value="beijing"></el-option>
    </el-select>
  </el-form-item>
  <el-form-item label="活动时间" required>
    <el-col :span="11">
      <el-form-item prop="date1">
        <el-date-picker type="date" placeholder="选择日期" v-model="ruleForm.date1" style="width: 100%;"></el-date-picker>
      </el-form-item>
    </el-col>
    <el-col class="line" :span="2">-</el-col>
    <el-col :span="11">
      <el-form-item prop="date2">
        <el-time-picker placeholder="选择时间" v-model="ruleForm.date2" style="width: 100%;"></el-time-picker>
      </el-form-item>
    </el-col>
  </el-form-item>
  <el-form-item label="即时配送" prop="delivery">
    <el-switch v-model="ruleForm.delivery"></el-switch>
  </el-form-item>
  <el-form-item label="活动性质" prop="type">
    <el-checkbox-group v-model="ruleForm.type">
      <el-checkbox label="美食/餐厅线上活动" name="type"></el-checkbox>
      <el-checkbox label="地推活动" name="type"></el-checkbox>
      <el-checkbox label="线下主题活动" name="type"></el-checkbox>
      <el-checkbox label="单纯品牌曝光" name="type"></el-checkbox>
    </el-checkbox-group>
  </el-form-item>
  <el-form-item label="特殊资源" prop="resource">
    <el-radio-group v-model="ruleForm.resource">
      <el-radio label="线上品牌商赞助"></el-radio>
      <el-radio label="线下场地免费"></el-radio>
    </el-radio-group>
  </el-form-item>
  <el-form-item label="活动形式" prop="desc">
    <el-input type="textarea" v-model="ruleForm.desc"></el-input>
  </el-form-item>
  <el-form-item>
    <el-button type="primary" @click="submitForm('ruleForm')">立即创建</el-button>
    <el-button @click="resetForm('ruleForm')">重置</el-button>
  </el-form-item>
</el-form>
<script>
  export default {
    data() {
      return {
        ruleForm: {
          name: '',
          region: '',
          date1: '',
          date2: '',
          delivery: false,
          type: [],
          resource: '',
          desc: ''
        },
        rules: {
          name: [
            { required: true, message: '请输入活动名称', trigger: 'blur' },
            { min: 3, max: 5, message: '长度在 3 到 5 个字符', trigger: 'blur' }
          ],
          region: [
            { required: true, message: '请选择活动区域', trigger: 'change' }
          ],
          date1: [
            { type: 'date', required: true, message: '请选择日期', trigger: 'change' }
          ],
          date2: [
            { type: 'date', required: true, message: '请选择时间', trigger: 'change' }
          ],
          type: [
            { type: 'array', required: true, message: '请至少选择一个活动性质', trigger: 'change' }
          ],
          resource: [
            { required: true, message: '请选择活动资源', trigger: 'change' }
          ],
          desc: [
            { required: true, message: '请填写活动形式', trigger: 'blur' }
          ]
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) => {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm(formName) {
        this.$refs[formName].resetFields();
      }
    }
  }
</script>
```

## 自定义校验规则

除此之外，我们还可以使用[validator](https://so.csdn.net/so/search?q=validator&spm=1001.2101.3001.7020)验证器来自定义校验规则，

举一个使用自定义验证规则来完成密码的二次验证的例子。

![img](https://img-blog.csdnimg.cn/331a69fcea2d4f22b39402e507980987.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_12,color_FFFFFF,t_70,g_se,x_16)

还是和之前一样，设置prop需校验的字段名和v-model绑定值

![img](https://img-blog.csdnimg.cn/02ba79382de44398a5dd235bc048c0dc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_20,color_FFFFFF,t_70,g_se,x_16)

但这时，我们需要在data中自己定义校验规则，需要注意的是，设置的规则与return同级。

![img](https://img-blog.csdnimg.cn/aafa47736e354a019b2692715c5cafaf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_11,color_FFFFFF,t_70,g_se,x_16)

在rules中配置要校验的字段和用到的规则

![img](https://img-blog.csdnimg.cn/a7519ef0d8644b59aee78f884f65d23c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5ZOm,size_11,color_FFFFFF,t_70,g_se,x_16)

完整代码如下：

```js
<el-form :model="ruleForm" status-icon :rules="rules" ref="ruleForm" label-width="100px" class="demo-ruleForm">
  <el-form-item label="密码" prop="pass">
    <el-input type="password" v-model="ruleForm.pass" autocomplete="off"></el-input>
  </el-form-item>
  <el-form-item label="确认密码" prop="checkPass">
    <el-input type="password" v-model="ruleForm.checkPass" autocomplete="off"></el-input>
  </el-form-item>
  <el-form-item label="年龄" prop="age">
    <el-input v-model.number="ruleForm.age"></el-input>
  </el-form-item>
  <el-form-item>
    <el-button type="primary" @click="submitForm('ruleForm')">提交</el-button>
    <el-button @click="resetForm('ruleForm')">重置</el-button>
  </el-form-item>
</el-form>
<script>
  export default {
    data() {
      var checkAge = (rule, value, callback) => {
        if (!value) {
          return callback(new Error('年龄不能为空'));
        }
        setTimeout(() => {
          if (!Number.isInteger(value)) {
            callback(new Error('请输入数字值'));
          } else {
            if (value < 18) {
              callback(new Error('必须年满18岁'));
            } else {
              callback();
            }
          }
        }, 1000);
      };
      var validatePass = (rule, value, callback) => {
        if (value === '') {
          callback(new Error('请输入密码'));
        } else {
          if (this.ruleForm.checkPass !== '') {
            this.$refs.ruleForm.validateField('checkPass');
          }
          callback();
        }
      };
      var validatePass2 = (rule, value, callback) => {
        if (value === '') {
          callback(new Error('请再次输入密码'));
        } else if (value !== this.ruleForm.pass) {
          callback(new Error('两次输入密码不一致!'));
        } else {
          callback();
        }
      };
      return {
        ruleForm: {
          pass: '',
          checkPass: '',
          age: ''
        },
        rules: {
          pass: [
            { validator: validatePass, trigger: 'blur' }
          ],
          checkPass: [
            { validator: validatePass2, trigger: 'blur' }
          ],
          age: [
            { validator: checkAge, trigger: 'blur' }
          ]
        }
      };
    },
    methods: {
      submitForm(formName) {
        this.$refs[formName].validate((valid) => {
          if (valid) {
            alert('submit!');
          } else {
            console.log('error submit!!');
            return false;
          }
        });
      },
      resetForm(formName) {
        this.$refs[formName].resetFields();
      }
    }
  }
</script>
```



------

## Vue中常用的rules校验规则

[原文链接：](https://blog.csdn.net/weixin_45934162/article/details/119677984)

前端Vue中常用rules校验规则:

```js
1、是否合法IP地址:

pattern:/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,

2.是否手机号码或者固话
pattern:/^((0\d{2,3}-\d{7,8})|(1[34578]\d{9}))$/,

3. 是否身份证号码
   pattern:/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/,

4.是否邮箱
pattern:/^([a-zA-Z0-9]+[-_\.]?)+@[a-zA-Z0-9]+\.[a-z]+$/,

5.整数填写
pattern:/^-?[1-9]\d*$/,

6.正整数填写
pattern:/^[1-9]\d*$/,

7.小写字母
pattern:/^[a-z]+$/,

8.大写字母
pattern:/^[A-Z]+$/,

9.大小写混合
pattern:/^[A-Za-z]+$/,

10.多个8位数字格式(yyyyMMdd)并以逗号隔开
pattern:/^\d{8}(\,\d{8})*$/,

11.数字加英文，不包含特殊字符
pattern:/^[a-zA-Z0-9]+$/,

12.前两位是数字后一位是英文
pattern:/^\d{2}[a-zA-Z]+$/,

13.密码校验（6-20位英文字母、数字或者符号（除空格），且字母、数字和标点符号至少包含两种）
pattern:/^(?![\d]+$)(?![a-zA-Z]+$)(?![^\da-zA-Z]+$)([^\u4e00-\u9fa5\s]){6,20}$/,

14.中文校验
pattern:/^[\u0391-\uFFE5A-Za-z]+$/,
```



------



# vue antd

------

## Antd组件Select中optionFilterProp=“children“问题及解决方案

今天在应用到Select组件时碰到这样一个问题：
select利用onSearch进行模糊查询（后端），后端给过来的内容不含有onsearch的value值然后会不展示，组件自动给进行了一层筛选，看图
在这里插入图片描述

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316141146768.png#pic_center)

后台数据：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316141322530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTIyNjg2Nw==,size_16,color_FFFFFF,t_70)

后台数据是不止俩条的，组件做了自动筛选，这并不是要的结果，

起初我想着将optionFilterProp="children"属性注释掉，结果出现另一个问题：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316141708572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTIyNjg2Nw==,size_16,color_FFFFFF,t_70)

以上即是我碰到的问题，后面去官网找办法发现optionFilterProp还有一个属性“label”，完美的解决了这个问题，根据模糊查询条件id结合内容拼在一块给一个label属性，这样怎么都能不被筛选排除了，看结果：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316142127765.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316142313531.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210316142428927.png)

数据都展示出来了。

------

实现组件的按需引入使用`babel-plugin-import`，详细见vue笔记

安装完后引入可全局引入详情查看vue笔记

也可以

## 配置按需引入：

### 1.新建utils文件夹在src根目录下，然后新建ant-demand.js

代码如下：

```js
import Vue from 'vue';

import {
  Button,
  Icon,
  Col,
  DatePicker,
  Row,
  Pagination,
  Modal,
  Input,
  Tabs,
  Radio,
  Select,
  Table,
  Checkbox,
  FormModel,
  Tooltip,
  ConfigProvider,
  Switch,
  TimePicker,
  InputNumber,
  Spin,
  Empty,
  Tag,
  List,
  Carousel,
  Dropdown,
  Divider,
} from 'ant-design-vue';

const antdPlugs = {
  Button,
  Icon,
  Col,
  DatePicker,
  Row,
  Pagination,
  Modal,
  Input,
  Tabs,
  Radio,
  Select,
  Table,
  Checkbox,
  FormModel,
  Tooltip,
  ConfigProvider,
  Switch,
  TimePicker,
  InputNumber,
  Spin,
  Empty,
  Tag,
  List,
  Carousel,
  Dropdown,
  Divider,
};

// 创建实例方法
Vue.prototype.$antdconfirm = Modal.confirm;
Vue.prototype.$info = Modal.info;
Vue.prototype.$success = Modal.success;
Vue.prototype.$error = Modal.error;
Vue.prototype.$warning = Modal.warning;

// 下面一块为转换对象为数组然后遍历，vue.use()动态调用
export const installAnt = () => {
  Object.keys(antdPlugs).forEach(keys => {
    Vue.use(antdPlugs[keys]);
  });
};

```

>Vue.prototype.$warning 实例使用：
>
>this.$warning即可，具体查看`vue笔记`

### 2.在main.js引入

```js
import { installAnt } from './utils/ant-demand'
// 加载ant-design-vue
installAnt()
```

### 3.修改babel.config.js

```
添加plugins: [['import', { libraryName: 'ant-design-vue', libraryDirectory: 'es', style: true }]]
```

全部：

```js
module.exports = {
  presets: ['@vue/cli-plugin-babel/preset'],
  plugins: [['import', { libraryName: 'ant-design-vue', libraryDirectory: 'es', style: true }]]
}

```









------



## Vue.use()的用法和install的用法解释

[引用](https://blog.csdn.net/weixin_35773751/article/details/123059916?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123059916-blog-114518978.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123059916-blog-114518978.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)

### 一、介绍

在vue的main.js中，我们经常使用Vue.use(xx)方法。比如我们引入elementUI，在main.js中，我们一般通过如下代码引入：

```js
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(ElementUI)
```

### 二、为什么这样做？

官方解释

> 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。什么意思呢？ Vue.use() 中的参数必须是一个function函数或者是一个Object对象，如果是对象的话，必须在对象中提供一个install方法。之后会将 Vue 作为参数传入。

总结：

>如果Vue.use() 中的参数是一个`function函数`，那么函数的参数是`Vue对象`。
>如果Vue.use() 中的参数是一个`Object对象`，那么这个对象必须提供一个install方法，install方法的参数就是Vue。

------

## Webpack打包之坑 _ webpackChunkName【魔法注释】

> [Webpack打包之坑 _ webpackChunkName【魔法注释】](https://blog.csdn.net/weixin_58099903/article/details/123919094)
>
> [手把手教你如何Vue项目打包dist文件并Tomcat发布【超级详细】](https://blog.csdn.net/m0_67401270/article/details/126081269)

> 事件起因 
> 蒽 ， 起因是这样的 ， 项目从最初的使用 vue-cli 脚手架搭建了一个初始化空架子之后就开始写项目了 ，也就是在刚开始的一段时间里偶尔有过几次打包查看 ，那时候还是能够顺利打包成功的 ，但随着代码越写越多 ，插件越来越多 ，项目也越来越大 ，但反而并没有再去尝试过打包了 ，就这样 ，项目在写到一半的时候 ，突然想起来要打包一下看看咋样 ，结果报错 ，报错 ，还是报错 ，不是说什么 .css 就是什么 .js 的文件提示没有啥的 ，这个问题组内的小伙伴解决了两天时间 ，最后还是在请教了一个大佬帮忙查看后才最终得以解决掉 ，所以这也算是个在项目中所遇到的技术问题难点了吧 ，哈哈 ，那就索性记录一下，也让自己以后好引以为戒啊。
>
> ![img](https://img-blog.csdnimg.cn/ec3ae66954b2413898cb18a8f6d0b1fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/017b839f23dd400492175d24ed276f71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/51a64667e4504308805570ef29ff7dc8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> 最后呢小伙伴给出的解释就是说 ：路由配置文件里面因为引用写了 webpack 的 魔法注释 而导致的打包失败 ，然后我就不是很理解 ，问了一下朋友 ，朋友说他们也用了 魔法注释 ， 并没有不能打包的情况啊 ， 所以百度了一下这个 webpack 所谓的 魔法注释 ，最后自己又在项目中一点点去调试  =>  先是把所有的路由配置里面的 webpack 魔法注释 都删除掉，然后先加上其中一个魔法注释，再去打包，结果顺利打包成功了，并没有报错 ，心想那应该就不是因为写了 魔法注释 的问题吧，随后又给一个路由加上了魔法注释后打包 ，发现也还是成功打包了 ，最后在朋友的提示下，说是 “ chunkname 可以用 * 吗 ？ ” ，然后就测试了一下把 ChunkName 起名为 * 号的那个加上后测试再打包就失败了，所以到最后发现影响打包失败的原因并不是人家 webpack 的魔法注释导致的 ， 而是 “起名不规范” 的原因啊 。 。
>
> （ * 号是不能作为名字来起文件名的 ）
>
> <img src="https://img-blog.csdnimg.cn/0e9977bb6db043b785b5bdab5d1e37ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:25%;" />
>
> ![img](https://img-blog.csdnimg.cn/eaa1c2fa320f4045ba464c61a7d2f8cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/3904b4ad6813499a985465b9080dc8eb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/4824793e82fb4b76995e9660e80db821.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/d0d9ff5566f942478c60ef7136d51b16.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
> ![img](https://img-blog.csdnimg.cn/34c340def7cf4991860a461149b23146.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA6Zuo5a2jbW_mtYXlv4Y=,size_20,color_FFFFFF,t_70,g_se,x_16)
>
>  好了 ， 这下就是找到了打包问题的根本原因所在了 ， webpack 的魔法注释 webpackChunkName 并不会影响打包 ， 而是起的名字有问题 ， 不规范导致的 ，
>
> 因为起的名字它好像是打包编译后会变成对应的文件名 ， 而既然是文件名了 ， 肯定就是不能够以 * 号进行命名滴 ！文件或文件夹名以 * 命名 会报错提示你 ：
>
> <font color='red'>名称 * 作为文件或文件夹名无效。请选择其他名称。</font>





------

# i5ting_toc

i5ting_toc 是一个可以把 md 文档转为 html 页面的小工具，使用步骤如下

```js
// 将 i5ting_toc 安装为全局包
npm install -g i5ting_toc
// 调用 i5ting_toc 轻松实现 md 转 html 功能
i5ting_toc -f 要转换的文件路径 -o
```

------

# Echarts

## echarts图表随屏幕的宽度自适应

[使用方法网址](https://blog.csdn.net/amao_aguai/article/details/83072742?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83072742-blog-121539620.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83072742-blog-121539620.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1) [参考1](https://blog.csdn.net/wch0001/article/details/121539620) [参考2](http://t.zoukankan.com/sugartang-p-12267523.html) [参考3](https://www.cnblogs.com/yongzhu/p/14931989.html) [参考3](https://blog.csdn.net/qq_42816550/article/details/91791190)

## 图表的自适应chart.resize()

有时候会遇到屏幕宽度在变化，而echarts的图表保持原宽度不变的情况：

![在这里插入图片描述](https://img-blog.csdn.net/20181016114106966?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtYW9fYWd1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

只需要在图表数据初始化函数之后，再resize()下就可以了。

```js
setTimeout(function (){
	    window.onresize = function () {
	    	twChart.resize();
	    }
	},200)
```

代码示例：

```html
<div class="chart_box">
	<div id="twChart" class="twChart"></div>
</div>
<script>
$(function(){
	option = {
		    title: {
		    },
		    tooltip: {
		        trigger: 'axis'
		    },
		    legend: {
		        data:['反馈','已审核','已上报']
		    },
		    grid: {
		        left: '3%',
		        right: '4%',
		        bottom: '3%',
		        containLabel: true
		    },
		    toolbox: {
		        feature: {
		            saveAsImage: {}
		        }
		    },
		    xAxis: {
		        type: 'category',
		        boundaryGap: false,
		        data: ['1月','2月','3月','4月','5月']
		    },
		    yAxis: {
		        type: 'value'
		    },
		    series: [
		        {
		            name:'反馈',
		            type:'line',
		            stack: '总量',
		            data:[120, 132, 101, 134, 90]
		        },
		        {
		            name:'已审核',
		            type:'line',
		            stack: '总量',
		            data:[220, 182, 191, 234, 290]
		        },
		        {
		            name:'已上报',
		            type:'line',
		            stack: '总量',
		            data:[150, 232, 201, 154, 190]
		        }
		       
		    ]
		};
	var twChart = echarts.init(document.getElementById('twChart'));
	twChart.setOption(option);
	setTimeout(function (){
	    window.onresize = function () {
	    	twChart.resize();
	    }
	},200)

})
</script>

```

图表就可以自适应了

![在这里插入图片描述](https://img-blog.csdn.net/20181016114732898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtYW9fYWd1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)











------

# npm i  下载安装他人设置好的所有依赖包

```
npm i 
```

> 在同一个项目中使用不同源的npm包，如何使用npm i
>
> 如此板块所言，我们可以创建公司的npm包，且公司的npm地址不同等于npm官方地址，当我们在开发阶段，我们可以使用nrm进行npm源切换，但是问题来了，更为方便的npm i,安装package.json中的依赖，就会报错，导致安装失败；

> 那么，能否在同一个项目中使用npm不同的源呢？

> 当然可以！

> 操作步骤
> 当你创建了一个公司的依赖包，则包名一般为@公司名/包名，示例：@ml/bytedance-sdk-for-node

> 此时，你只需要将自己的npm的配置增加根据某个前缀定向修改源的配置即可，
> 例如：当依赖包前缀为@ml时，使用源地址 ：https://npm.malong360.top/

> npm config set @banu:registry=https://npm.malong360.top/
> **至此，你就可以使用npm i进行安装了；**

> 同时，使用此方法修改依赖包的安装源之后，可以随意使用npm进行安装官方包，以及公司包，不必再使用nrm进行源切换！

> 这个方法适用于日常开发和线上项目部署！

------

# vue中延时函数用法

```js
setTimeout(() => {
           this.$refs.window222.query();
       }, 500);
```



------

# 拿到别人的vue项目之后如何运行

首先先说情况：

一、你拿到的是别人直接打包好的成品
二、你拿到的是别人给你的源码，里边连依赖（node_modules）都存在的一个超大的压缩包
三、别人放 git 上或者别人把 依赖（node_modules）删除之后给你的一个不大不小的压缩包，源码

来说这三种情况哈：

第一种，直接放你服务器根目录就可以访问了，不用运行，当然，这种的你改也没法改

至于第二种和第三种，首先如果是个小白得话，建议你先看看这篇博文【看看】

知道如何用 vue 创建项目得话，会简单很多

第二种：
在刚才那篇博文里面已经安装好了 vue 运行需要得环境，那么第二种你先将项目里边的 node_modules 文件夹整个删除，然后命令行进入项目根目录，运行 npm install ，等安装好了依赖之后，运行 npm run dev（如果对方没自定义指令的话这个是通用的），这时候项目就跑起来了，命令行有提示当前项目运行的本地地址

第三种：
没有依赖的源码项目，这种的不用考虑，上来先 npm install 一下，再运行 npm run dev ，看命令行启动的地址是什么，直接访问就行

备注：
如何查看自定义指令
找到项目根目录的 package.json 文件，找到 scripts ，里边的就是自定义的指令

比如我这里的：想运行 build 指令，直接在命令行运行 npm run build

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3a08643c6f2483fa2161139f17665a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zac5aSn5pmu5aWU4oG24oG24oG2,size_18,color_FFFFFF,t_70,g_se,x_16)

# 输入框失去焦点显示按键，通过按键显示输入框

```vue
<template>

	<input type='text' v-if="inputVisible" @blur="showButton" />
	<button v-else @click="showInput">展示文本框</button>

</template>
<script>
export default{
	data(){
		return{
			inputVisible: false
		}
	},
	methods: {
		showInput(){
			this.inputVisible = true
		},
		showButton(){
			this.inputVisible = false
		}
	}
}
</script>
```

------



------

# Ant-Design-vue的a-table入门

https://www.jianshu.com/p/ff75f39e3cd0

------

# 【antd-design】实例详解a-table 中column中slot-scope=“{text, record, index}

[参考](https://blog.csdn.net/weixin_43853746/article/details/122449676?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449676-blog-90294091.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449676-blog-90294091.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)

三者表示的值如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/771cfcf1a75d4701a6ec636724c16b51.png)

text表示本项内容对应的字段值value，record的值是object，表示的是这一行数据的全部内容，index表示当行索引

在column 中如何一个单元格显示多个变量，前面介绍了，这里就可以很清晰的知道用record可以是实现：

例如我们后台返回的区域名和建筑名用> 串接起来显示在一个单元格内：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0071fc9ed5b84bd68815c1c4e7453c8e.png)

a-table中：

```html
<div slot="estate" slot-scope="{text, record, index}">
    <span>{{ record.estate_name }} > {{ record.building_name }}</span>
</div>
```


column.js:

```
  {
   title: '区域名',
   width: 250,
   fixed: 'left',
   scopedSlots: { customRender: 'estate' }
 },
```



------

# 【Vue】滚动条（设置滚动条、滚动条样式、鼠标移入滚动条显示移出滚动条隐藏....）

https://blog.csdn.net/Qxn530/article/details/126647153

# 设置滚动条

可以使用overflow属性设置是否出现滚动条。

同时需要指定盒子高度或宽度，当超出指定尺寸时，就会出现滚动条

x、y方向：overflow：[scroll](https://so.csdn.net/so/search?q=scroll&spm=1001.2101.3001.7020)

x方向：overflow-x：scroll

y方向：overflow-y：scroll

```css
.box {
    height: 500px;
    overflow: hidden;// 超出部分隐藏
    overflow-y: scroll; // 设置y轴方向的滚动条
}
```

## 滚动条样式

- ::-[webkit](https://so.csdn.net/so/search?q=webkit&spm=1001.2101.3001.7020)-scrollbar 滚动条整体部分
- ::-webkit-scrollbar-button 滚动条两端的按钮
- ::-webkit-scrollbar-track 外层轨道
- ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）
- ::-webkit-scrollbar-thumb 滚动条里面可以拖动的那个
- ::-webkit-scrollbar-corner 边角
- 
  ::-webkit-resizer 定义右下角拖动块的样式

### 1、隐藏滚动条

```css
// 隐藏滚动条
 .el-tab-pane::-webkit-scrollbar {
   width: 0 !important;
   height: 0px !important;
 }
```

### 2、常用滚动条的样式的示例

 ![img](https://img-blog.csdnimg.cn/a311ac8a2a614fc4b77ca19e00a616f9.png)

```css
.box {
    padding: 30px 20px 30px 50px;
    height: 500px;
    overflow: hidden;
    white-space: nowrap
    overflow-y: scroll;// 设置滚动条
 
  /*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/
  // 滚动条整体部分
  &::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  // 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。
  &::-webkit-scrollbar-button {
    display: none;
  }
  // 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）
  &::-webkit-scrollbar-thumb {
    background: rgba(144, 147, 153, 0.3);
    cursor: pointer;
    border-radius: 4px;
  }
  // 边角，即两个滚动条的交汇处
  &::-webkit-scrollbar-corner {
    display: none;
  }
  // 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件
  &::-webkit-resizer {
    display: none;
  }
 
}
```

## 滚动条的应用

### 1、标签页的内容滚动，标签头部固定

只要修改css样式：给元素添加高度和overflow：auto或给父元素添加即可

子盒子的高度需要根据屏幕自适应

```vue
<template>
  <div class="app-container">
    <el-tabs v-model="activeName">
      <el-tab-pane label="用户管理" name="first">用户管理</el-tab-pane>
      <el-tab-pane label="配置管理" name="second">配置管理</el-tab-pane>
      <el-tab-pane label="角色管理" name="third">角色管理</el-tab-pane>
    </el-tabs>
  </div>
</template>
 
 
<style lang='scss' scoped>
.el-tab-pane {
  height: 500px;
  overflow-y: auto;
}
</style>
```

### ***\*2、鼠标移入显示滚动条，鼠标移出隐藏滚动条\****

```html
<div class="table"></div>
 
<style lang='scss' scoped>
.table {
  height: 700px;
  overflow: hidden;
}
.table:hover {
  height: 700px;
  overflow-y: auto;
}
</style>
```

### 3、***\*实现导航栏鼠标上滑显示下滑隐藏\****

首先我们要在DOM加载完毕之后获取滚轮事件，把滚轮位置赋值给data中的top变量，用watch[监听](https://so.csdn.net/so/search?q=监听&spm=1001.2101.3001.7020)top的newValue和oldValue值，当新值比旧值大的时候证明滚轮在向下滚动，触发相对应事件，反之亦然。

```vue
<!-- 第一步 -->
<navbar id="nav-bar" :class="navShow ? 'navOn' : 'navOff'" />
 
<script>
  //第三步： 获取浏览器滚轮
  mounted () {
    window.addEventListener('scroll', () => {
      this.top = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset
    })
  },
  //第四步： 监听top值的变化
  watch: {
    top (newValue, oldValue) {
      // 等新值大于100的时候再做变化（优化一下）
      if (newValue > 100) {
        if (newValue > oldValue) {
          this.navShow = false
          console.log('向下滚动')
        } else {
          this.navShow = true
          console.log('向上滚动')
        }
      }
    }
  },
  data () {
     return {
        // 第二步
        top: '',
        navShow: true,
      }
  },
}
</script>
<style lang="scss" scoped>
// 第五步
.navOn {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  transition: all 0.2s ease-in-out 0.2s;
  transform: translateZ(0);
  z-index: 9;
}
.navOff {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  transition: all 0.2s ease-in-out 0.2s;
  transform: translate3d(0, -100%, 0);
  z-index: 9;
}
</style>
```

### 4、表格中的滚动条（空白处理）

![img](https://img-blog.csdnimg.cn/7598ffc674b54cb2be5daf4fcd6ed31b.png)

```css
 //滚动条空白
  //表头
  .el-table--border th:last-child {
    border-right: none;
  }
  .el-table__fixed-right-patch {
    // background-color: #152345 !important; //如果表头有背景色，在这里添加即可
  }
 
 //表格内容处
 .el-table td:last-child {
    border-right: none;
  }
```

最后的效果就是这样啦，没有什么特别好的方法，如果你有的话留言一下呗。

![img](https://img-blog.csdnimg.cn/ca21fa3a1f024787a5c376fabe7a97b2.png)

------

# 提高样式优先级

!important

```css
.ant-tabs-extra-content {
  float: left !important;
  position: absolute;
}
```



------

# Vue项目中的接口调用

在企业开发过程中，往往有着明确的前后端的分工，前端负责接收、使用接口，后端负责编写、处理接口。

对于前端如何使用接口，今天在Vue中进行讲解。

一个项目往往由这几个部分组成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e07ffc1875ba4431ba4974453ba194e7.png)

其中在src文件夹中，有这么些内容。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ce69167d478b41d3919513a6c6bfef1e.png)

我们常常把接口文件，新建一个文件夹在src下，命名为[api](https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020)，api内的文件便是接口文件。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4d0e8e7cb6314c8c9fc9525a3f89d1a1.png)

通常把后端的接口写在api文件夹下，自己命名为xxx.js

```js
// 登录
export function login(data) {
  return request({
    url: '/api/court/login',
    method: 'post',
    data
  })
}
// 获取验证码
export function captchaImage(params) {
  return request({
    url: '/api/captchaImage',
    method: 'get',
    params
  })
}

```

对于需要添加信息在头部的，可以这么写

```js
// 获取登录用户信息
export function getInfo(params) {
  return request({
    url: '/api/court/getInfo',
    method: 'get',
    params,
    headers: {
      'Authorization': JSON.parse(localStorage.Authorization)
  }
  })
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d175abf6010243b7af7829fa2d3792c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

这个就是request.js 文件的内容

![在这里插入图片描述](https://img-blog.csdnimg.cn/1729607db8c34869ba4c78b8fd797eb3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_18,color_FFFFFF,t_70,g_se,x_16)

```js
import axios from 'axios'
// import { getToken } from '@/utils/auth'

// create an axios instance
const service = axios.create({
  // 外网更新
  // baseURL: 'http://xxxxx',
  baseURL: '/xxxxx',  
  timeout: 5000 // request timeout
})

export default service

```

项目的页面往往写在views中，每个页面设一个文件夹，其中index.vue 内容则是本页面的内容

![在这里插入图片描述](https://img-blog.csdnimg.cn/e1bef25f73ea4d8094ab678fb94d6757.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

在页面中，如果我们需要使用某个接口。则需要进行引入操作。通过 import {接口名1、接口名2} from ’ api文件地址 ’

```js
import { login,captchaImage,getInfo,logOut,reset } from '@/api/login'

```

from后所跟的就是api中文件的地址路径

接口往往是在方法中进行调用，对于不同接口 ，需要的参数也不一样，根据需求，我们传入对应的参数即可。图中的 captchaImage、以及login就是接口信息。

接口的使用格式：

接口名({参数1:页面中的参1，参数2：页面中的参数2}).then(res => {
console.log(res)//res就是调用接口后，后台返回过来的结果，一般数据储存在res.data.data中，具体情况而论

![在这里插入图片描述](https://img-blog.csdnimg.cn/de131c8dd9614722a3c46827d13504ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

这样就是接口调用的全部过程了。附上控制台信息图以及apipost接口图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/14c65c554a8e4263b5ffc1edb29f1efc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/e35ac014af244b939d8495d09566ef43.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/f2bb9a15ab3d47f29a61c6c53b193813.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

------

# 表格功能

### 效果：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-02_16-48-50.png)

### 注意1：数据`list`结构

> 第一个 a-form-model 控制表格个数，每次新增会在列表 list 中push一个对象（包含时间和能否编辑，还有一个包含数据"里程、自提、配送左右俩数字"的列表，对象内新增对象），
>
> list：[ { 规则1：时间，[ {规则数据第一行} ] }，{ 规则2 }，{ 规则3 } ]

```js
list：[  { 规则1：时间，[ {规则数据第一行} ，{规则数据第二行}  ] } , { 规则2 } , { 规则3 }  ]

list:[
	{   //规则1
		key: this.$_.uniqueId(),
        edit: true,
        pickTimeBegin: pickTimeBeginMoment.format('HH:mm'),
        pickTimeEnd: pickTimeEndMoment.format('HH:mm'),
        pickTimeBeginMoment,
        pickTimeEndMoment,
        ruleList: [
        	{	//行内数据 第一行
        		key: this.$_.uniqueId(),
        		mileageLeft: '',
        		mileageRight: '',
        		selfDateLeft: '0',
        		selfDateRight: '0',
        		deliveryDateLeft: '0',
        		deliveryDateRight: '0',
      		},
      		{  //第二行
      		...
      		},
        ],
	},
	{  //规则2
	...
	}
]
```

### 注意2：

required是做什么用的:这个是加了后，label前面会有星号,这个不会触发校验

![image-20221103143118213](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143118213.png)

在rules里面配置，也会有星号，但是会触发校验了

![image-20221103143222251](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143222251.png)

### 注意3：时间使用moment来实现

包括现在时间`this.$moment()`，判断末端时间是否在起始时间前：isSameOrAfter()

moment().isSameOrAfter(Moment|String|Number|Date|Array); moment().isSameOrAfter(Moment|String|Number|Date|Array, String);

> 检查一个 moment 是否在另一个 moment 之后或与之相同。 第一个参数会被解析为 moment（如果尚未解析）。

```
moment('2010-10-20').isSameOrAfter('2010-10-19'); // true
moment('2010-10-20').isSameOrAfter('2010-10-20'); // true
moment('2010-10-20').isSameOrAfter('2010-10-21'); // false
```

### 注意4：引用全局函数js来判断是否非空

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-04-58.png)

> 详解查看Vue的`Vue.prototype`详解	

### 注意5：全局提示实现

在main.js中添加全局 ant-design-vue方法组件 message ，然后通过this.$message调用。具体查看ant-design-vue文档

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-27-36.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-40-14.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-39-39.png)

常用方法：（包括成功、失败、警告。

```vue
<template>
  <div>
    <a-button @click="success">
      Success
    </a-button>
    <a-button @click="error">
      Error
    </a-button>
    <a-button @click="warning">
      Warning
    </a-button>
  </div>
</template>
<script>
export default {
  methods: {
    success() {
      this.$message.success('This is a success message');
    },
    error() {
      this.$message.error('This is an error message');
    },
    warning() {
      this.$message.warning('This is a warning message');
    },
  },
};
</script>

```











### 代码：

| allowClear | 是否展示清除按钮      | boolean | true                  |
| ---------- | --------------------- | ------- | --------------------- |
| openChange | 面板打开/关闭时的回调 |         | (open: boolean): void |

```vue
<!-- 里程区间组件 -->
<template>
  <div class="config">
    <a-button v-if="isPlan" type="primary" class="config-add" @click.stop="addForm">新增规则</a-button>
    <a-form-model v-for="(item, index) in list" :key="item.key" labelAlign="left" class="config-form">
      <template v-if="isPlan">
        <a v-if="list.length > 1" class="config-form-delete delete-icon" @click.stop="list.splice(index, 1)" />
        <a-form-model-item label="下单时间" :required="true">
          <a-time-picker v-model="item.pickTimeBeginMoment" format="HH:mm" :allowClear="false"
                         @change="changePickTime(item)" />
          <span class="config-form-interval all-center">~</span>
          <!-- 第一个disabledHours是组件的禁用API，第二个是调用事件 -->
          <a-time-picker v-model="item.pickTimeEndMoment" format="HH:mm" :allow-clear="false"
                         :disabledHours="() => disabledHours(item)" :disabledMinutes="() => disabledMinutes(item)"
                         @openChange="changePickTime(item)" />
        </a-form-model-item>
      </template>
      <template v-if="item.edit">
        <a-button type="primary" @click.stop="addRule(item)">添加里程区间</a-button>
        <template v-if="isPlan || isInventoryEdit">
          <a-button type="primary" @click.stop="saveRule(item, index)">保存</a-button>
          <a-button v-if="!$isEmpty(data[index]) && !$isEmpty(data[index].ruleList)"
                    @click.stop="cancelRule(item, index)">
            取消
          </a-button>
        </template>
      </template>
      <a-button v-else key="edit" type="primary" @click.stop="item.edit = true">修改</a-button>
      <a-table :columns="columns" :dataSource="item.ruleList" :bordered="true" :pagination="false">
        <template slot="mileage" slot-scope="text, record, rowIndex">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.mileageLeft" :min="0" />
              &nbsp;&nbsp;&lt;&nbsp;&nbsp;里程&nbsp;&nbsp;≤&nbsp;&nbsp;
              <a-input-number v-model="record.mileageRight" :min="0" />
            </template>
            <template v-else>
              {{ record.mileageLeft }}
              <template v-if="!$isEmpty(record.mileageLeft)">&lt;&nbsp;&nbsp;</template>
              <span>里程</span>
              <template v-if="!$isEmpty(record.mileageRight)">&nbsp;&nbsp;≤</template>
              {{ record.mileageRight }}
            </template>
            <a v-if="item.edit && item.ruleList.length > 1" class="config-row-delete delete-icon"
               @click.stop="item.ruleList.splice(rowIndex, 1)" />
          </div>
        </template>
        <template slot="since" slot-scope="text, record">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.selfDateLeft" :min="0"
                              @blur.stop="numberInputBlur(record, 'selfDateLeft')" />
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                <a-input-number v-model="record.selfDateRight" :min="0"
                                @blur.stop="numberInputBlur(record, 'selfDateRight')" />
              </template>
            </template>
            <template v-else>
              {{ record.selfDateLeft }}
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                {{ record.selfDateRight }}
              </template>
            </template>
          </div>
        </template>
        <template slot="delivery" slot-scope="text, record">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.deliveryDateLeft" :min="0"
                              @blur.stop="numberInputBlur(record, 'deliveryDateLeft')" />
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                <a-input-number v-model="record.deliveryDateRight" :min="0"
                                @blur.stop="numberInputBlur(record, 'deliveryDateRight')" />
              </template>
            </template>
            <template v-else>
              {{ record.deliveryDateLeft }}
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                {{ record.deliveryDateRight }}
              </template>
            </template>
          </div>
        </template>
      </a-table>
    </a-form-model>
  </div>
</template>

<script>
export default {
  name: 'ruleConfig',
  props: {
    data: {
      type: Array,
      default: () => [],
    },
    type: { // 0：计划判断，1：库存配置新增、2：库存配置修改
      type: String,
      default: '0',
    },
  },
  data() {
    return {
      list: [],
      columns: [
        { title: '里程区间（公里）', width: 300, scopedSlots: { customRender: 'mileage' } },
        { title: '自提（计划提货日期+ x 天）', width: 300, scopedSlots: { customRender: 'since' } },
        { title: '配送（期望到货日期-x 天）', width: 300, scopedSlots: { customRender: 'delivery' } },
      ],
    };
  },
  computed: {
    isPlan() {
      return this.type === '0';
    },
    isInventoryEdit() {
      return this.type === '2';
    },
  },
  methods: {
    init() {
      if (this.$isEmpty(this.data)) {
        this.addForm();
      } else {
        this.list = this.data.map(item => ({
          ...item,
          key: item.id || this.$_.uniqueId(),
          edit: item.edit || this.$isEmpty(item.ruleList),
          mileageLeft: this.$isEmpty(item.mileageLeft) ? '' : parseFloat(item.mileageLeft),
          mileageRight: this.$isEmpty(item.mileageRight) ? '' : parseFloat(item.mileageRight),
          pickTimeBeginMoment: this.$moment(item.pickTimeBegin, 'HH:mm'),
          pickTimeEndMoment: this.$moment(item.pickTimeEnd, 'HH:mm'),
          ruleList: item.edit ? item.ruleList : this.initRuleList(item.ruleList),
        }));
      }
    },
    initRuleList(ruleList) {
      return ruleList.map(item => {
        const [selfDateLeft, selfDateRight] = item.selfDate?.toString()?.split('-') || ['0', '0'];
        const [deliveryDateLeft, deliveryDateRight] = item.deliveryDate?.toString()?.split('-') || ['0', '0'];

        return {
          ...item,
          key: item.id || this.$_.uniqueId(),
          selfDateLeft,
          selfDateRight,
          deliveryDateLeft,
          deliveryDateRight,
        };
      });
    },
    addForm() { //增加规则
      const pickTimeBeginMoment = this.$moment();
      const pickTimeEndMoment = this.$moment().add(1, 'h');
      const item = {
        key: this.$_.uniqueId(),
        edit: true,
        pickTimeBegin: pickTimeBeginMoment.format('HH:mm'),
        pickTimeEnd: pickTimeEndMoment.format('HH:mm'),
        pickTimeBeginMoment,
        pickTimeEndMoment,
        ruleList: [],
      };
      this.addRule(item); //增加规则内的行数
      this.list.push(item); //规则并入 list列表
    },
    disabledHours(item) {	// 禁用起始时间之前的小时选项
      const hours = item.pickTimeBeginMoment.hours();
      const disabled = [];	// 禁用列表
      for (let i = 0; i < hours; i++) {
        disabled.push(i);
      }

      if (item.pickTimeBeginMoment.minutes() === 59) {
        disabled.push(hours);
      }

      return disabled;
    },
    disabledMinutes(item) {
      if (item.pickTimeBeginMoment.hours() === item.pickTimeEndMoment.hours()) {
        const disabled = [];
        for (let i = 0; i < item.pickTimeBeginMoment.minutes() + 1; i++) {
          disabled.push(i);
        }

        return disabled;
      }

      return [];
    },
    changePickTime(item) {  	// 每次下单时间变化引发事件判断是否末端时间小于起始时间
      if (item.pickTimeBeginMoment.isSameOrAfter(item.pickTimeEndMoment)) {
        item.pickTimeEndMoment = this.$moment(item.pickTimeBeginMoment).add(1, 'h');	// 若末端时间小于起始时间，则 末时间等于起始加1，使用moment的add必须用 moment().add() 语法
      }
      item.pickTimeBegin = item.pickTimeBeginMoment.format('HH:mm');	// 同样也要更改pickTimeBegin的值
      item.pickTimeEnd = item.pickTimeEndMoment.format('HH:mm');
    },
    numberInputBlur(item, key) {
      if (this.$isEmpty(item[key])) {
        item[key] = 0;
      }
    },
    addRule(item) {  	// 默认规则第一行数据
      item.ruleList.push({
        key: this.$_.uniqueId(),
        mileageLeft: '',
        mileageRight: '',
        selfDateLeft: '0',
        selfDateRight: '0',
        deliveryDateLeft: '0',
        deliveryDateRight: '0',
      });
    },
    saveRule(item) {	// 保存事件
      if (this.checkRule(item.ruleList)) {	// 判断
        item.ruleList = item.ruleList.map(item => ({
          ...item,
          selfDate: this.isPlan ? `${item.selfDateLeft}-${item.selfDateRight}` : item.selfDateLeft,
          deliveryDate: this.isPlan ? `${item.deliveryDateLeft}-${item.deliveryDateRight}` : item.deliveryDateLeft,
        }));

        if (this.$dataType.isFunction(this.$listeners.onSave)) {
          this.$emit('onSave', item.ruleList, () => {
            item.edit = false;
            this.$emit('update:data', this.list);
          });
        } else {
          item.edit = false;
          this.$emit('update:data', this.list);
        }
      }
    },
    checkRule(ruleList) {	// 
      const { length } = ruleList;

      for (let i = 0; i < length; i++) {	// 循环当前规则的每一行数据
        const { mileageLeft, mileageRight } = ruleList[i];	// 赋值解构出 里程左值和右值
        const hasNotMileageLeft = this.$isEmpty(mileageLeft);	// 判断是否为空，空true
        const hasNotMileageRight = this.$isEmpty(mileageRight); // 同上

        if (hasNotMileageLeft && hasNotMileageRight) {	// 若同时为空值则弹出报错返回给saveRule事件false
          this.$message.warning('请输入里程最小值或里程最大值');
          return false;
        }

        if (!hasNotMileageLeft && !hasNotMileageRight && mileageLeft >= mileageRight) { 
          this.$message.warning('里程最小值不能大于或等于里程最大值');
          return false;
        }

        const $mileageLeft = this.$isEmpty(mileageLeft) ? -window.Infinity : mileageLeft + 1;
        const $mileageRight = this.$isEmpty(ruleList[i].mileageRight) ? window.Infinity : mileageRight;
        for (let j = 0; j < length; j++) {
          const _mileageLeft = this.$isEmpty(ruleList[j].mileageLeft) ? -window.Infinity : ruleList[j].mileageLeft + 1;
          const _mileageRight = this.$isEmpty(ruleList[j].mileageRight) ? window.Infinity : ruleList[j].mileageRight;

          if (i !== j && Math.max($mileageLeft, _mileageLeft) <= Math.min($mileageRight, _mileageRight)) {
            this.$message.warning('里程区间不可重复');
            return false;
          }
        }
      }

      return true;
    },
    cancelRule(item, index) {
      item.edit = false;
      item.ruleList = this.initRuleList(this.data[index].ruleList);
    },
    getRuleList() {
      const { length } = this.list;
      for (let i = 0; i < length; i++) {
        if (!this.checkRule(this.list[i].ruleList)) {
          return false;
        }

        const pickTimeBegin = this.$moment(this.list[i].pickTimeBeginMoment.format('HH:mm'), 'HH:mm').valueOf();
        const pickTimeEnd = this.$moment(this.list[i].pickTimeEndMoment.format('HH:mm'), 'HH:mm').valueOf();
        for (let j = 0; j < length; j++) {
          const _pickTimeBegin = this.$moment(this.list[j].pickTimeBeginMoment.format('HH:mm'), 'HH:mm').valueOf();
          const _pickTimeEnd = this.$moment(this.list[j].pickTimeEndMoment.format('HH:mm'), 'HH:mm').valueOf();

          if (i !== j && Math.max(pickTimeBegin, _pickTimeBegin) <= Math.min(pickTimeEnd, _pickTimeEnd)) {
            this.$message.warning('时间区间不可重复');
            return false;
          }
        }
      }

      return this.list;
    },
  },
  watch: {
    data: {
      immediate: true,
      handler() {
        this.init();
      },
    },
  },
};
</script>

<style lang="scss" scoped>
.config {
  .ant-btn {
    min-width: 68px;
    font-size: 12px;
    margin-bottom: 12px;

    &.config-add {
      width: 102px;
    }

    &:not(.ant-btn-primary) {
      background-color: transparent;
    }

    & + .ant-btn {
      margin-left: 8px;
    }
  }

  .config-form {
    position: relative;
    padding: 16px;
    background-color: #f7f7f7;

    & + .config-form {
      margin-top: 8px;
    }

    .delete-icon {
      position: absolute;
      z-index: 1;
      width: 16px;
      height: 16px;

      &.config-form-delete {
        top: 24px;
        right: 17px;
        background: url(../../assets/imager/delete_red_close.png) no-repeat;
        background-size: 100% 100%;
      }

      &.config-row-delete {
        top: 50%;
        left: 10px;
        background: url(../../assets/imager/delete_red_minus.png) no-repeat;
        background-size: 100% 100%;
        transform: translate(0, -50%);
      }
    }

    .ant-time-picker {
      width: 112px;
    }

    .config-form-interval {
      display: inline-flex;
      width: 16px;
    }

    /deep/ .ant-form-item-label {
      width: 94px;

      label {
        color: #333;
        font-size: 14px;
      }
    }

    /deep/ .ant-table {
      .ant-table-thead {
        th {
          height: 30px;
          text-align: center !important;
          padding: 0;
          border-bottom: none;
          background-color: #f7f7f7 !important;
        }
      }

      .ant-table-tbody {
        td {
          position: relative;
          height: 52px;
          border-color: #d8d8d8;
          border-bottom: none;
          background-color: #fff;
          box-shadow: inset 0px -1px 0 0 #d9d9d9;
        }
      }
    }
  }
}
</style>

```

判断是否为空：

```js
// 判断是否为空
export const isEmpty = value => {
  switch (dataType.getType(value)) {
    case 'Set':
    case 'Map':
      return value.size === 0;
    case 'Object':
      return Object.keys(value).length === 0;
    case 'Array':
      return value.length === 0;
    default:
      return ['', null, undefined].includes(value);
  }
};

// 获取数据类型
const getType = value => Object.prototype.toString.call(value).slice(8, -1);

// 数据类型操作
export const dataType = {
  getType,
  isMap: value => getType(value) === 'Map',
  isSet: value => getType(value) === 'Set',
  isObject: value => getType(value) === 'Object',
  isArray: value => getType(value) === 'Array',
  isFunction: value => getType(value) === 'Function',
  isDate: value => getType(value) === 'Date',
  isReg: value => getType(value) === 'RegExp',
  isString: value => getType(value) === 'String',
  isNumber: value => getType(value) === 'Number',
  isBoolean: value => getType(value) === 'Boolean',
  isNull: value => getType(value) === 'Null',
  isUndefined: value => getType(value) === 'Undefined',
};
```

message弹窗

> 使用的是ant-design-vue的message组件

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-27-36.png)









------

# 实现星号

required是做什么用的:这个是加了后，label前面会有星号,这个不会触发校验

![image-20221103143118213](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143118213.png)

在rules里面配置，也会有星号，但是会触发校验了

![image-20221103143222251](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143222251.png)

------

# 截取片段

```js
const data = r.data;
const startIndex = data.indexOf('window');
const endIndex = data.lastIndexOf('window');
console.log(JSON.parse(r.data.substring(startIndex + 17, endIndex - 18)));
```

## substring字符串截取

https://blog.csdn.net/way343922/article/details/122084066

## js的indexOf方法

https://blog.csdn.net/Smile_666666/article/details/119595672





------











/myOrder/quoteList

/myOrder/quoteDetail

18670380849   111111aaWSX

```apl
ifUnloading 02 非分卸 01 分卸
deliveryMode 02 配送 01 自提
```









1. 学一门脚本语音（py） 文本语言（js） 前端框架（vue react）后端框架（py的dj 或者java spring）

   了解运维的工作过程
   
   再去学一下测试抓包
   
   数据库也学两吧 关系型 非关系型
   
   主流的mysql和redis



>features/0630-supportOrderRejection
>
>hotfixes/0620-stationPopup
>
>17788998206 dev
>
>
>
>18684705001
>
>http://localhost:8080/#/bidd/orderDetail?agreeid=196F4EB10493EEAB17B58229608F3256
>
>```apl
>PNG竞价：gasweb/#/bidd/orderDetail?agreeid=xxxxx&fromType=sale
>
>path: '/bidd/orderDetail',
>    name: 'biddOrderDetail',
>    component: () => import('@/views/bidd/biddOrderDetail'),
>
>PNG预售：gasweb/#/zhoushan/orderDetail?agreeId=xxxxx&fromType=sale
>
>path: '/zhoushan/orderDetail',
>    name: 'orderDetail',
>    component: () => import('@/views/zhoushan/orderDetail'),
>
>--------------------------
>& fromType != 'sale' && isBuyer) ||
>        (isAgree.agree == '2' && fromType != 'purchase
>```
>
>/new/entrustAgree/pngCancelAgree?output=JSON
>
>```
>description: "测试"
>extAddress: ""
>file: ""
>filePostfix: ""
>reasonCode: "01"
>```
>
>![image-20230619154958530](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20230619154958530.png)
>
>```apl
>/entrustAgree/pngBatchRejectAgree
>
>reasonCode : 01：管容预约失败, 02：管输费超标, 03：其它reasonCode : 01：管容预约失败, 02：管输费超标, 03：其它
>description 是内容
>文件上传后 会返回一个字段：filePostfix  应该就是这个里面的 filePostfix
>/new/fileInfo/img/5ad8fe96cf10939d489e06b9869eb62f  这个是extAddress，最后面这串ID 用上传接口返回的 fileId替换就行
>/fileInfo/upload
>```
>
>![image-20230619165359974](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20230619165359974.png)
>
>嗯嗯是后缀
>
>![img](https://static.dingtalk.com/media/lQLPJwgdIj0Qh5rMm80DPLDchHkoB4oBuwSGU5rwQPQA_828_155.png)
