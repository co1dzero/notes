# 公司

厂家：18684705001     密码：111111aaWSX
买家：18500000001    密码：111111aaWSX        
卖家：18670380849   111111aaWSX

https://test.greatgas.cn/new/

------

# npm 相关问题

## npm i 安装时-D 和 -S的区别是什么？

npm安装时-S -D的区别是什么？

> -S
> 即–save（保存）
> 包名会被注册在package.json的dependencies里面，在生产环境下这个包的依赖依然存在。
> 如安装lodash：

```js
npm i --save lodash
```

> -D
> 即–dev（开发）
> 包名会被注册在package.json的devDependencies里面，仅在开发环境下存在的包用-D，如babel，sass-loader这些解析器。

注意：在使用npm install一个插件的时候，需要添加上-s或-d，不然不会在package.json中显示插件名称及版本号。

------

## npm i安装依赖问题添加公司源

源http://10.39.36.124:8080/nexus/repository/npm-public/

> nrm 这个是包源管理的小工具
>
> npm i nrm -g
>
> nrm add local http://10.39.36.124:8080/nexus/repository/npm-public/
>
> nrm use local
>
> 再安装依赖包就好了

------

## 安装组件库或安装依赖报错

[引用](https://blog.csdn.net/jolinoy/article/details/123948912)

报错信息：

```coffeescript
npm ERR! code ERESOLVE
npm ERR! ERESOLVE unable to resolve dependency tree
npm ERR! 
npm ERR! While resolving: test-first@0.1.0
npm ERR! Found: vue@2.7.14
npm ERR! node_modules/vue
npm ERR!   vue@"^2.6.14" from the root project
npm ERR! 
npm ERR! Could not resolve dependency:
npm ERR! peer vue@">=3.2.0" from ant-design-vue@3.2.15
npm ERR! node_modules/ant-design-vue
npm ERR!   ant-design-vue@"*" from the root project
npm ERR! 
npm ERR! Fix the upstream dependency conflict, or retry
npm ERR! this command with --force, or --legacy-peer-deps
npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
npm ERR!
npm ERR! See C:\Users\shizeyu\AppData\Local\npm-cache\eresolve-report.txt for a full report.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\shizeyu\AppData\Local\npm-cache\_logs\2022-12-27T00_28_37_936Z-debug-0.log
```

输入npm -V发现我的npm版本为8.x的，因为npm7.x版本对某些命令比npm6.x更严格

<font color='red'>解决办法有两种：</font>
1.在命令后加上`--legacy-peer-deps`
2.使用npm6.x

> 提示：使用npm@6不需要[卸载npm](https://so.csdn.net/so/search?q=卸载npm&spm=1001.2101.3001.7020)@7。可以使用npx指定npm的版本。例如：`npx -p npm@6 npm i --legacy-peer-deps`

> 如果这不能立即起作用，可以先删除 `node_modules`和 `package-lock.json`

```
例如安装ant-design

npm install ant-design-vue --save基础上加上--legacy-peer-deps
npm install ant-design-vue --save --legacy-peer-deps
```









------



## 代码提交的注释规范

upd: 用于更新代码，fix: 用于修改bug，主要就是这俩

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\lQLPJx4_STDfZ4TNA1jNAyWw-1nyN3jD2u4DlDcY4cCMAA_805_856.png)

## 各种环境（dev、test、sit、uat、prod、pre、fat）

>dev（Development environment）：开发环境。用于开发者调试使用。
>
>test：测试环境。
>
>sit（System Integration Test）：系统集成测试。
>
>uat（User Acceptance environment）：用户验收测试环境。生产环境下的软件测试者测试使用。预发布环境。
>
>pre：灰度环境。灰度测试环境就是生产环境，生产数据，所影响的也是生产环境，只是范围比测试环境更广，更真实。其实就是小范围的生产环境。类似于游戏内测。
>
>fat（Feature Acceptance Test environment）：功能验收测试环境。软件测试者测试使用。
>
>prod（Production environment）：生产环境。正式线上环境。











------

# JS

------

## CSS Flex 布局的引入背景

[引入](https://www.jianshu.com/p/526df5aa5812)

flex 布局背后的主要思想是让容器能够改变其项目的宽度/高度（和顺序）以自适应地填充可用空间（主要是为了适应所有类型的显示设备和屏幕尺寸）。弹性容器扩展 item 以填充可用的可用空间，在必要时也会收缩容器内元素的宽度，以防止溢出(overflow)

由于 flexbox 是一个完整的模块而不是一个单一的属性，它涉及很多东西，包括它的整个属性集。 其中一些要设置在容器（父元素，称为 `flex container`）上，而剩下的属性要设置在子元素（称为 `flex item`）上。

如果常规布局基于块和内联流向，则弹性布局基于弹性流向。 下面这张图解释了 flex 布局背后的主要思想。

![img](https://upload-images.jianshu.io/upload_images/2085791-2eb070731e6daea8.png?imageMogr2/auto-orient/strip|imageView2/2/w/982/format/webp)

Flex 容器里的 items 元素，要么沿着 main 轴方向布局，要么沿着 cross 轴方向布局。

Flex 容器和容器里的 item 元素的对应关系如下图所示：

![img](https://upload-images.jianshu.io/upload_images/2085791-d107ce2d3941e4b4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1181/format/webp)

display:flex 这个 css 属性即可将一个容器设置成 `Flex` 布局的容器：

![img](https://upload-images.jianshu.io/upload_images/2085791-788198ce64d1fb64.png?imageMogr2/auto-orient/strip|imageView2/2/w/449/format/webp)

------

## isEmpty()

判断是否为空

------

正则

```js
priceClass: item.floats > 0 ? 'red' : item.floats < 0 ? 'green' : 'gray3'
```

------

## ||  运算符

（比如let a = b || c）

JavaScript
1、JS中的||符号：
运算方法：
只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。
只要“||”前面为true,不管“||”后面是true还是false，都返回“||”前面的值。
比如：var a= b || c
这相当于一个赋值语句，如果b的值被转换为false，那么就把c的值赋给a，否在就把b的值赋给a
javascript中以下值会被转换为false

------



## encodeURI() 函数

```
var uri="my test.php?name=ståle&car=saab";
document.write(encodeURI(uri)+ "<br>");
```

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-29_11-51-15.png)

------

## includes()

[网址](https://www.cnblogs.com/webSnow/p/16121867.html)

```
js中的includes用法

1.数组
includes 可以判断一个数组中是否包含某一个元素，并返回true 或者false
['a','b','c'].includes('a')
true

['a','b','c'].includes(1)
false


includes可以包含两个参数，第二个参数表示判断的起始位置

起始位置第一个数字是0。
2.字符串  查找字符串是否包含 "Runoob":
  var str = "Hello world, welcome to the Runoob。"; var n = str.includes("Runoob");
  n 输出结果:  true
```

------

## ?.  运算符的使用

### 可选链操作符(?.)

语法

```scss
obj?.prop
obj?.[expr]
func?.(args)
```

### **使用介绍**

比如，我们有一个对象obj，现在要访问它的深层属性baz。

```js
const obj = {
  foo: {
    bar: {
      baz: 42,
      fun: ()=>{}
    },
  },
};
 
// 不使用?.
let baz = obj && obj.foo && obj.foo.bar && obj.foo.bar.baz;
 
// 使用?.
let baz = obj?.foo?.bar?.baz; // 结果：42
 
 
 
```

函数调用和表达式

>```js
>// 函数调用
>obj.fn?.()
>// 表达式
>obj?.['prop' + 'Name]
>```

------

## ...  扩展运算符

### 什么意思？

三个点（...）真名叫扩展[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)，是在ES6中新增加的内容，它可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开；还可以在构造字面量对象时将对象表达式按照key-value的方式展开

> 字面量一般指[1,2,3]或者{name:'chuichui'}这种简洁的构造方式,多层嵌套的数组和对象三个点就无能为力了

```js
// 数组
var number = [1,2,3,4,5,6]
console.log(...number) //1 2 3 4 5 6
//对象
var man = {name:'chuichui',height:176}
console.log({...man}) / {name:'chuichui',height:176}
```

### 有什么用？

它的用处很广泛，我们随处都可以看到，下面是几个常见的例子

#### 复制用它

```js
//数组的复制
var arr1 = ['hello']
var arr2 =[...arr1]
arr2 // ['hello']
//对象的复制
var obj1 = {name:'chuichui'}
var obj2 ={...arr}
ob12 //  {name:'chuichui'}
```

#### 合并用它

```js
//数组的合并
var arr1 = ['hello']
var arr2 =['chuichui']
var mergeArr = [...arr1,...arr2]
mergeArr  // ['hello','chuichui']
// 对象分合并
var obj1 = {name:'chuichui'}
var obj2 = {height:176}
var mergeObj = {...obj1,...obj2}
mergeObj // {name: "chuichui", height: 176}
```

#### 字符转数组用它

```js
var arr1 = [...'hello']
arr1 // ["h", "e", "l", "l", "o"]
```

#### 函数传参用它

可以和正常的函数相结合，灵活使用

```js
function f(v,w,x,y,z){ }
var args = [2,3]
f(1,...args,4,...[5])
```

当我们想把数组中的元素迭代为函数参数时，用它！

```js
function f(x,y,z){}
var args = [1,2,3]
f(...args)
 
// 以前的方法
f.apply(null,args);
```

------

## Promise

> `Promise `是一个 `ECMAScript 6 `提供的类，目的是更加优雅地书写复杂的异步任务。

### 构造 `Promise`

现在我们新建一个` Promise `对象：

```js
new Promise(function (resolve, reject) {
    // 要做的事情...
});
```

通过新建一个` Promise `对象好像并没有看出它怎样 "更加优雅地书写复杂的异步任务"。我们之前遇到的异步任务都是一次异步，如果需要多次调用异步函数呢？例如，如果我想分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒：

```js
setTimeout(function () {
    console.log("First");
    setTimeout(function () {
        console.log("Second");
        setTimeout(function () {
            console.log("Third");
        }, 3000);
    }, 4000);
}, 1000);
```

这段程序实现了这个功能，但是它是用 "函数瀑布" 来实现的。可想而知，在一个复杂的程序当中，用 "函数瀑布" 实现的程序无论是维护还是异常处理都是一件特别繁琐的事情，而且会让缩进格式变得非常冗赘。

**现在我们用` Promise `来实现同样的功能：**

```js
new Promise(function (resolve, reject) {
    setTimeout(function () {
        console.log("First");
        resolve();
    }, 1000);
}).then(function () {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log("Second");
            resolve();
        }, 4000);
    });
}).then(function () {
    setTimeout(function () {
        console.log("Third");
    }, 3000);
});
```

 <font color='red'>`Promise `将嵌套格式的代码变成了顺序格式的代码。</font>

### `Promise `的使用

下面我们通过剖析这段 Promise "计时器" 代码来讲述 Promise 的使用：

`Promise `构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数<font color='red'>` resolve `</font>和<font color='red'>` reject`</font>。

当` Promise `被构造时，起始函数会被异步执行：

```js
new Promise(function (resolve, reject) {
    console.log("Run");
});
```

这段程序会直接输出 **Run**。

<font color='red'>`resolve `和` reject `都是函数，其中调用` resolve `代表一切正常，`reject `是出现异常时所调用的：</font>

```js
new Promise(function (resolve, reject) {
    var a = 0;
    var b = 1;
    if (b == 0) reject("Divide zero");
    else resolve(a / b);
}).then(function (value) {
    console.log("a / b = " + value);
}).catch(function (err) {
    console.log(err);
}).finally(function () {
    console.log("End");
});
```

这段程序执行结果是:

```js
a / b = 0
End
```

`Promise` 类有` .then() .catch() `和` .finally() `三个方法，这三个方法的参数都是一个函数，`.then() `可以将参数中的函数添加到当前 Promise 的正常执行序列，`.catch() `则是设定` Promise `的异常处理序列，`.finally() `是在` Promise `执行的最后一定会执行的序列。` .then() `传入的函数会按顺序依次执行，有任何异常都会直接跳到` catch `序列：

```js
new Promise(function (resolve, reject) {
    console.log(1111);
    resolve(2222);
}).then(function (value) {
    console.log(value);
    return 3333;
}).then(function (value) {
    console.log(value);
    throw "An error";
}).catch(function (err) {
    console.log(err);
});
```

执行结果：

```js
1111
2222
3333
An error
```

<font color='red'>`resolve() `中可以放置一个参数用于向下一个` then `传递一个值，`then `中的函数也可以返回一个值传递给` then`。但是，如果` then `中返回的是一个` Promise `对象，那么下一个` then `将相当于对这个返回的` Promise `进行操作，这一点从刚才的计时器的例子中可以看出来。</font>

`reject() `参数中一般会传递一个异常给之后的 catch 函数用于处理异常。

<font color='red'>**但是请注意以下两点：**</font>

- **`resolve `和` reject `的作用域只有起始函数**，不包括` then `以及其他序列；
- `resolve `和` reject `并不能够使起始函数停止运行，别忘了` return`。

### `Promise `函数

上述的 "计时器" 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个**自定义的` Promise` 函数**：

```js
function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}
```

然后我们就可以放心大胆的实现程序功能了：**（调用函数）**

```js
print(1000, "First").then(function () {
    return print(4000, "Second");
}).then(function () {
    print(3000, "Third");
});
```

### 回答常见的问题（FAQ）

>**Q: then、catch 和 finally 序列能否顺序颠倒？**
>
>A: 可以，效果完全一样。但不建议这样做，最好按 then-catch-finally 的顺序编写程序。

> **Q: 除了 then 块以外，其它两种块能否多次使用？**
>
> A: 可以，finally 与 then 一样会按顺序执行，但是 catch 块只会执行第一个，除非 catch 块里有异常。所以最好只安排一个 catch 和 finally 块。

> **Q: then 块如何中断？**
>
> A: then 块默认会向下顺序执行，return 是不能中断的，可以通过 throw 来跳转至 catch 实现中断。

> **Q: 什么时候适合用 Promise 而不是传统回调函数？**
>
> A: 当需要多次顺序执行异步操作的时候，例如，如果想通过异步方法先后检测用户名和密码，需要先异步检测用户名，然后再异步检测密码的情况下就很适合 Promise。

> **Q: Promise 是一种将异步转换为同步的方法吗？**
>
> A: 完全不是。Promise 只不过是一种更良好的编程风格。

> **Q: 什么时候我们需要再写一个 then 而不是在当前的 then 接着编程？**
>
> A: 当你又需要调用一个异步任务的时候。

### 异步函数

异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。

在 Promise 中我们编写过一个 Promise 函数：

```js
function print(delay, message) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            console.log(message);
            resolve();
        }, delay);
    });
}
```

然后用不同的时间间隔输出了三行文本：**(调用)**

```js
print(1000, "First").then(function () {
    return print(4000, "Second");
}).then(function () {
    print(3000, "Third");
});
```

我们可以将这段代码变得更好看：

```js
async function asyncFunc() {
    await print(1000, "First");
    await print(4000, "Second");
    await print(3000, "Third");
}
asyncFunc();
```

哈！这岂不是将异步操作变得像同步操作一样容易了吗！

这次的回答是肯定的，异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。

异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。

处理异常的机制将用 try-catch 块实现：

```js
async function asyncFunc() {
    try {
        await new Promise(function (resolve, reject) {
            throw "Some error"; // 或者 reject("Some error")
        });
    } catch (err) {
        console.log(err);
        // 会输出 Some error
    }
}
asyncFunc();
```

如果 Promise 有一个正常的返回值，await 语句也会返回它：

```js
async function asyncFunc() {
    let value = await new Promise(
        function (resolve, reject) {
            resolve("Return value");
        }
    );
    console.log(value);
}
asyncFunc();
```

程序会输出:

```js
Return value
```



------

## async 

async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。

### 语法

```js
async function name([param[, param[, ... param]]]) { statements }
```

- name: 函数名称。
- param: 要传递给函数的参数的名称。
- statements: 函数体语句。

### 返回值

async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。

```js
async function helloAsync(){
    return "helloAsync";
  }
  
console.log(helloAsync())  // Promise {<resolved>: "helloAsync"}
 
helloAsync().then(v=>{
   console.log(v);         // helloAsync
})
```

async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。

await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。

```js
function testAwait(){
   return new Promise((resolve) => {
       setTimeout(function(){
          console.log("testAwait");
          resolve();
       }, 1000);
   });
}
 
async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
 }
helloAsync();
// testAwait
// helloAsync
```

## await

await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。

### 语法

```
[return_value] = await expression;
```

- expression: 一个 Promise 对象或者任何要等待的值。

### 返回值

返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。

如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。

```js
function testAwait (x) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}
 
async function helloAsync() {
  var x = await testAwait ("hello world");
  console.log(x); 
}
helloAsync ();
// hello world
```

正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。

```js
function testAwait(){
   console.log("testAwait");
}
async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
}
helloAsync();
// testAwait
// helloAsync
```

await针对所跟不同表达式的处理方式：

- Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。
- 非 Promise 对象：直接返回对应的值。

示例：

```js
test() {
      async function a() {
        await console.log('2')

        console.log('1')
      }
      a()
      console.log('3')
      console.log('3')
      console.log('3')
      console.log('3')
    }
test()

// 输出
2
3
3
3
3
1
```





------

# git

利用命令行删除 git 本地仓库

在此文件夹下，右键打开 `git bash here`，输入命令

```c
find . -name ".git" | xargs rm -Rf
```

 查看远程仓库中所有的分支

```
git remote show 远程仓库名
例如：
git remote show origin
```

查看本地分支

```
git branch 
```

push和fetch的地址

```
git remote -v
```

## vscode

1. Commit只会记录您在本地计算机上所做的更改。它不会标记远程存储库中的更改。
2. Commit和Push将执行上述操作并将其推送到远程存储库。这意味着您所做的任何更改也将保存到远程存储库中。
3. 提交和同步做三件事。首先，它会提交本地仓库。其次，它将执行拉动`fetch + merge 或 fetch + rebase`（从远程仓库获取更新的信息）。最后，它会推动`push`。

> 所以是不是可以这样理解：在本地仓库为空的情况下，首次用git pull从远程仓库将最新内容拉到本地仓库&工作区，在工作区更新代码后通过add和commit提交到本地仓库，再次用git fetch+git merge将最新远程仓库内容拉取到本地仓库（可能远程仓库有更新），解决冲突后再git push到远程仓库

------

# axios

![img](C:\Users\shizeyu\Desktop\notes\Ajax-vue\DFC122C6-C33F-44fb-B9D3-558C348007BF.png)

> 传参可以使用params和query两种方式。
>
> `params`提供`query`参数也会挂载到网址`url`上，data则是body参数不会挂载到`url`上



## mockjs 组件假数据

[引用](https://blog.csdn.net/qsj0606/article/details/124587940)

### 关于[mock](https://so.csdn.net/so/search?q=mock&spm=1001.2101.3001.7020).js，官网描述

```javascript
1.前后端分离
2.不需要修改既有代码，就可以拦截 Ajax 请求，返回模拟的响应数据
3.数据类型丰富
4.通过随机数据，模拟各种场景
1234
```

### 1、安装mockjs

```javascript
npm install mockjs
//或 在开发环境中引入
npm install mockjs --save-dev
123
```

### 2、创建mock.js文件

1. 在src路径下创建mock.js文件
2. 在main.js引入mock.js文件

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020103114360435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

### 3、mock.js使用

1.在刚刚创建的mock.js文件中写入测试代码

```javascript
//引入mockjs
const Mock = require('mockjs')   //安装的mockjs，并不是创建的mock.js
// 获取 mock.Random 对象
const Random = Mock.Random;
//使用mockjs模拟数据
Mock.mock('/api/data', (req, res) => {//当post或get请求到/api/data路由时Mock会拦截请求并返回上面的数据
    let list = [];
    for(let i = 0; i < 30; i++) {
        let listObject = {
            title: Random.csentence(5, 10),//随机生成一段中文文本。
            company: Random.csentence(5, 10),
            attention_degree: Random.integer(100, 9999),//返回一个随机的整数。
            photo: Random.image('114x83', '#00405d', '#FFF', 'Mock.js')
        }
        list.push(listObject);
    }
    return {
        data: list
    }
})
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143744782.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

2.在xxx.vue文件中使用axios获取mock.js中的随机数据

```javascript
import axios from 'axios'

export default {
      data() {
        return {
          data:[]
        }
      },
      mounted:function() {
        axios.get('/api/data').then(res => {//get()中的参数要与mock.js文件中的Mock.mock()配置的路由保持一致
          this.data = res.data.data;
          console.log(res.data);//在console中看到数据
        }).catch(res => {
          alert('wrong');
        })
      },
      methods:{
          
      }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143825963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

< template >< /template >结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143857263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)

效果展示

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201031143922115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NkZ29nbw==,size_16,color_FFFFFF,t_70#pic_center)



------

# vue antd

实现组件的按需引入使用`babel-plugin-import`，详细见vue笔记

安装完后引入可全局引入详情查看vue笔记

也可以

## 配置按需引入：

### 1.新建utils文件夹在src根目录下，然后新建ant-demand.js

代码如下：

```js
import Vue from 'vue';

import {
  Button,
  Icon,
  Col,
  DatePicker,
  Row,
  Pagination,
  Modal,
  Input,
  Tabs,
  Radio,
  Select,
  Table,
  Checkbox,
  FormModel,
  Tooltip,
  ConfigProvider,
  Switch,
  TimePicker,
  InputNumber,
  Spin,
  Empty,
  Tag,
  List,
  Carousel,
  Dropdown,
  Divider,
} from 'ant-design-vue';

const antdPlugs = {
  Button,
  Icon,
  Col,
  DatePicker,
  Row,
  Pagination,
  Modal,
  Input,
  Tabs,
  Radio,
  Select,
  Table,
  Checkbox,
  FormModel,
  Tooltip,
  ConfigProvider,
  Switch,
  TimePicker,
  InputNumber,
  Spin,
  Empty,
  Tag,
  List,
  Carousel,
  Dropdown,
  Divider,
};

// 创建实例方法
Vue.prototype.$antdconfirm = Modal.confirm;
Vue.prototype.$info = Modal.info;
Vue.prototype.$success = Modal.success;
Vue.prototype.$error = Modal.error;
Vue.prototype.$warning = Modal.warning;

// 下面一块为转换对象为数组然后遍历，vue.use()动态调用
export const installAnt = () => {
  Object.keys(antdPlugs).forEach(keys => {
    Vue.use(antdPlugs[keys]);
  });
};

```

>Vue.prototype.$warning 实例使用：
>
>this.$warning即可，具体查看`vue笔记`

### 2.在main.js引入

```js
import { installAnt } from './utils/ant-demand'
// 加载ant-design-vue
installAnt()
```

### 3.修改babel.config.js

```
添加plugins: [['import', { libraryName: 'ant-design-vue', libraryDirectory: 'es', style: true }]]
```

全部：

```js
module.exports = {
  presets: ['@vue/cli-plugin-babel/preset'],
  plugins: [['import', { libraryName: 'ant-design-vue', libraryDirectory: 'es', style: true }]]
}

```









------



## Vue.use()的用法和install的用法解释

[引用](https://blog.csdn.net/weixin_35773751/article/details/123059916?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123059916-blog-114518978.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-123059916-blog-114518978.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)

### 一、介绍

在vue的main.js中，我们经常使用Vue.use(xx)方法。比如我们引入elementUI，在main.js中，我们一般通过如下代码引入：

```js
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(ElementUI)
```

### 二、为什么这样做？

官方解释

> 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。什么意思呢？ Vue.use() 中的参数必须是一个function函数或者是一个Object对象，如果是对象的话，必须在对象中提供一个install方法。之后会将 Vue 作为参数传入。

总结：

>如果Vue.use() 中的参数是一个`function函数`，那么函数的参数是`Vue对象`。
>如果Vue.use() 中的参数是一个`Object对象`，那么这个对象必须提供一个install方法，install方法的参数就是Vue。



------

# Echarts

## echarts图表随屏幕的宽度自适应

[使用方法网址](https://blog.csdn.net/amao_aguai/article/details/83072742?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83072742-blog-121539620.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-83072742-blog-121539620.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1) [参考1](https://blog.csdn.net/wch0001/article/details/121539620) [参考2](http://t.zoukankan.com/sugartang-p-12267523.html) [参考3](https://www.cnblogs.com/yongzhu/p/14931989.html) [参考3](https://blog.csdn.net/qq_42816550/article/details/91791190)

## 图表的自适应chart.resize()

有时候会遇到屏幕宽度在变化，而echarts的图表保持原宽度不变的情况：

![在这里插入图片描述](https://img-blog.csdn.net/20181016114106966?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtYW9fYWd1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

只需要在图表数据初始化函数之后，再resize()下就可以了。

```js
setTimeout(function (){
	    window.onresize = function () {
	    	twChart.resize();
	    }
	},200)
```

代码示例：

```html
<div class="chart_box">
	<div id="twChart" class="twChart"></div>
</div>
<script>
$(function(){
	option = {
		    title: {
		    },
		    tooltip: {
		        trigger: 'axis'
		    },
		    legend: {
		        data:['反馈','已审核','已上报']
		    },
		    grid: {
		        left: '3%',
		        right: '4%',
		        bottom: '3%',
		        containLabel: true
		    },
		    toolbox: {
		        feature: {
		            saveAsImage: {}
		        }
		    },
		    xAxis: {
		        type: 'category',
		        boundaryGap: false,
		        data: ['1月','2月','3月','4月','5月']
		    },
		    yAxis: {
		        type: 'value'
		    },
		    series: [
		        {
		            name:'反馈',
		            type:'line',
		            stack: '总量',
		            data:[120, 132, 101, 134, 90]
		        },
		        {
		            name:'已审核',
		            type:'line',
		            stack: '总量',
		            data:[220, 182, 191, 234, 290]
		        },
		        {
		            name:'已上报',
		            type:'line',
		            stack: '总量',
		            data:[150, 232, 201, 154, 190]
		        }
		       
		    ]
		};
	var twChart = echarts.init(document.getElementById('twChart'));
	twChart.setOption(option);
	setTimeout(function (){
	    window.onresize = function () {
	    	twChart.resize();
	    }
	},200)

})
</script>

```

图表就可以自适应了

![在这里插入图片描述](https://img-blog.csdn.net/20181016114732898?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FtYW9fYWd1YWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)











------

# npm i  下载安装他人设置好的所有依赖包

```
npm i 
```

> 在同一个项目中使用不同源的npm包，如何使用npm i
>
> 如此板块所言，我们可以创建公司的npm包，且公司的npm地址不同等于npm官方地址，当我们在开发阶段，我们可以使用nrm进行npm源切换，但是问题来了，更为方便的npm i,安装package.json中的依赖，就会报错，导致安装失败；

> 那么，能否在同一个项目中使用npm不同的源呢？

> 当然可以！

> 操作步骤
> 当你创建了一个公司的依赖包，则包名一般为@公司名/包名，示例：@ml/bytedance-sdk-for-node

> 此时，你只需要将自己的npm的配置增加根据某个前缀定向修改源的配置即可，
> 例如：当依赖包前缀为@ml时，使用源地址 ：https://npm.malong360.top/

> npm config set @banu:registry=https://npm.malong360.top/
> **至此，你就可以使用npm i进行安装了；**

> 同时，使用此方法修改依赖包的安装源之后，可以随意使用npm进行安装官方包，以及公司包，不必再使用nrm进行源切换！

> 这个方法适用于日常开发和线上项目部署！

------

# vue中延时函数用法

```js
setTimeout(() => {
           this.$refs.window222.query();
       }, 500);
```



------

# 拿到别人的vue项目之后如何运行

首先先说情况：

一、你拿到的是别人直接打包好的成品
二、你拿到的是别人给你的源码，里边连依赖（node_modules）都存在的一个超大的压缩包
三、别人放 git 上或者别人把 依赖（node_modules）删除之后给你的一个不大不小的压缩包，源码

来说这三种情况哈：

第一种，直接放你服务器根目录就可以访问了，不用运行，当然，这种的你改也没法改

至于第二种和第三种，首先如果是个小白得话，建议你先看看这篇博文【看看】

知道如何用 vue 创建项目得话，会简单很多

第二种：
在刚才那篇博文里面已经安装好了 vue 运行需要得环境，那么第二种你先将项目里边的 node_modules 文件夹整个删除，然后命令行进入项目根目录，运行 npm install ，等安装好了依赖之后，运行 npm run dev（如果对方没自定义指令的话这个是通用的），这时候项目就跑起来了，命令行有提示当前项目运行的本地地址

第三种：
没有依赖的源码项目，这种的不用考虑，上来先 npm install 一下，再运行 npm run dev ，看命令行启动的地址是什么，直接访问就行

备注：
如何查看自定义指令
找到项目根目录的 package.json 文件，找到 scripts ，里边的就是自定义的指令

比如我这里的：想运行 build 指令，直接在命令行运行 npm run build

![在这里插入图片描述](https://img-blog.csdnimg.cn/e3a08643c6f2483fa2161139f17665a9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Zac5aSn5pmu5aWU4oG24oG24oG2,size_18,color_FFFFFF,t_70,g_se,x_16)

# 输入框失去焦点显示按键，通过按键显示输入框

```vue
<template>

	<input type='text' v-if="inputVisible" @blur="showButton" />
	<button v-else @click="showInput">展示文本框</button>

</template>
<script>
export default{
	data(){
		return{
			inputVisible: false
		}
	},
	methods: {
		showInput(){
			this.inputVisible = true
		},
		showButton(){
			this.inputVisible = false
		}
	}
}
</script>
```

------

# 文字内容超出两行时显示省略号

文字内容超出两行时显示省略号

```html
<view class="newsTitle">
	这里是一条很长很长很长的内容
</view>
```

设置内容超出两行显示省略号的css样式如下：

```js
.newsTitle{
	width: 536rpx;  //设置宽度
	font-size: 32rpx;
	font-weight: 700;
	line-height: 52rpx;
	text-align: left;
	color: #333333;
    
	overflow: hidden;
	text-overflow: ellipsis;
	display: -webkit-box;  //使用自适应布局
	-webkit-line-clamp: 2;  //设置超出行数，要设置超出几行显示省略号就把这里改成几
	-webkit-box-orient: vertical;
}

```

这个样式可用于uniapp的微信小程序开发。

1.语法:text-overflow:clip|ellipsis

默认值:clip;

适用于:所有元素

clip:当前对象内文本溢出时不显示省略标记(...),而是将溢出部分裁剪。

ellipsis:当对象内文本一处时显示省略标记(...)。

当然这还是不够的，需要加点调料才能出现效果:

那就是配合

```css
overflow:hidden

white-space:overflow;
```

2.这时候BT的产品经理来了，小鹏啊~一行省略怎么行，变成三行出现省略。

处理办法:

将white-space去除，并且加上:

```css
display:-webkit-box;

-webkit-line-clamp: 3/*第几行裁剪*/

-webkit-box-orient:vertical;
```

-webkit-line-clamp 用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。 常见结合属性：
2-1.display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。
2-2.-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。
2-3.text-overflow: ellipsis; ，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。

------

# Ant-Design-vue的a-table入门

https://www.jianshu.com/p/ff75f39e3cd0

------

# 【antd-design】实例详解a-table 中column中slot-scope=“{text, record, index}

[参考](https://blog.csdn.net/weixin_43853746/article/details/122449676?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449676-blog-90294091.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122449676-blog-90294091.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1)

三者表示的值如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/771cfcf1a75d4701a6ec636724c16b51.png)

text表示本项内容对应的字段值value，record的值是object，表示的是这一行数据的全部内容，index表示当行索引

在column 中如何一个单元格显示多个变量，前面介绍了，这里就可以很清晰的知道用record可以是实现：

例如我们后台返回的区域名和建筑名用> 串接起来显示在一个单元格内：

![在这里插入图片描述](https://img-blog.csdnimg.cn/0071fc9ed5b84bd68815c1c4e7453c8e.png)

a-table中：

```html
<div slot="estate" slot-scope="{text, record, index}">
    <span>{{ record.estate_name }} > {{ record.building_name }}</span>
</div>
```


column.js:

```
  {
   title: '区域名',
   width: 250,
   fixed: 'left',
   scopedSlots: { customRender: 'estate' }
 },
```



------

# 【Vue】滚动条（设置滚动条、滚动条样式、鼠标移入滚动条显示移出滚动条隐藏....）

https://blog.csdn.net/Qxn530/article/details/126647153

# 设置滚动条

可以使用overflow属性设置是否出现滚动条。

同时需要指定盒子高度或宽度，当超出指定尺寸时，就会出现滚动条

x、y方向：overflow：[scroll](https://so.csdn.net/so/search?q=scroll&spm=1001.2101.3001.7020)

x方向：overflow-x：scroll

y方向：overflow-y：scroll

```css
.box {
    height: 500px;
    overflow: hidden;// 超出部分隐藏
    overflow-y: scroll; // 设置y轴方向的滚动条
}
```

## 滚动条样式

- ::-[webkit](https://so.csdn.net/so/search?q=webkit&spm=1001.2101.3001.7020)-scrollbar 滚动条整体部分
- ::-webkit-scrollbar-button 滚动条两端的按钮
- ::-webkit-scrollbar-track 外层轨道
- ::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分（除去）
- ::-webkit-scrollbar-thumb 滚动条里面可以拖动的那个
- ::-webkit-scrollbar-corner 边角
- 
  ::-webkit-resizer 定义右下角拖动块的样式

### 1、隐藏滚动条

```css
// 隐藏滚动条
 .el-tab-pane::-webkit-scrollbar {
   width: 0 !important;
   height: 0px !important;
 }
```

### 2、常用滚动条的样式的示例

 ![img](https://img-blog.csdnimg.cn/a311ac8a2a614fc4b77ca19e00a616f9.png)

```css
.box {
    padding: 30px 20px 30px 50px;
    height: 500px;
    overflow: hidden;
    white-space: nowrap
    overflow-y: scroll;// 设置滚动条
 
  /*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/
  // 滚动条整体部分
  &::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  // 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。
  &::-webkit-scrollbar-button {
    display: none;
  }
  // 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）
  &::-webkit-scrollbar-thumb {
    background: rgba(144, 147, 153, 0.3);
    cursor: pointer;
    border-radius: 4px;
  }
  // 边角，即两个滚动条的交汇处
  &::-webkit-scrollbar-corner {
    display: none;
  }
  // 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件
  &::-webkit-resizer {
    display: none;
  }
 
}
```

## 滚动条的应用

### 1、标签页的内容滚动，标签头部固定

只要修改css样式：给元素添加高度和overflow：auto或给父元素添加即可

子盒子的高度需要根据屏幕自适应

```vue
<template>
  <div class="app-container">
    <el-tabs v-model="activeName">
      <el-tab-pane label="用户管理" name="first">用户管理</el-tab-pane>
      <el-tab-pane label="配置管理" name="second">配置管理</el-tab-pane>
      <el-tab-pane label="角色管理" name="third">角色管理</el-tab-pane>
    </el-tabs>
  </div>
</template>
 
 
<style lang='scss' scoped>
.el-tab-pane {
  height: 500px;
  overflow-y: auto;
}
</style>
```

### ***\*2、鼠标移入显示滚动条，鼠标移出隐藏滚动条\****

```html
<div class="table"></div>
 
<style lang='scss' scoped>
.table {
  height: 700px;
  overflow: hidden;
}
.table:hover {
  height: 700px;
  overflow-y: auto;
}
</style>
```

### 3、***\*实现导航栏鼠标上滑显示下滑隐藏\****

首先我们要在DOM加载完毕之后获取滚轮事件，把滚轮位置赋值给data中的top变量，用watch[监听](https://so.csdn.net/so/search?q=监听&spm=1001.2101.3001.7020)top的newValue和oldValue值，当新值比旧值大的时候证明滚轮在向下滚动，触发相对应事件，反之亦然。

```vue
<!-- 第一步 -->
<navbar id="nav-bar" :class="navShow ? 'navOn' : 'navOff'" />
 
<script>
  //第三步： 获取浏览器滚轮
  mounted () {
    window.addEventListener('scroll', () => {
      this.top = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset
    })
  },
  //第四步： 监听top值的变化
  watch: {
    top (newValue, oldValue) {
      // 等新值大于100的时候再做变化（优化一下）
      if (newValue > 100) {
        if (newValue > oldValue) {
          this.navShow = false
          console.log('向下滚动')
        } else {
          this.navShow = true
          console.log('向上滚动')
        }
      }
    }
  },
  data () {
     return {
        // 第二步
        top: '',
        navShow: true,
      }
  },
}
</script>
<style lang="scss" scoped>
// 第五步
.navOn {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  transition: all 0.2s ease-in-out 0.2s;
  transform: translateZ(0);
  z-index: 9;
}
.navOff {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  transition: all 0.2s ease-in-out 0.2s;
  transform: translate3d(0, -100%, 0);
  z-index: 9;
}
</style>
```

### 4、表格中的滚动条（空白处理）

![img](https://img-blog.csdnimg.cn/7598ffc674b54cb2be5daf4fcd6ed31b.png)

```css
 //滚动条空白
  //表头
  .el-table--border th:last-child {
    border-right: none;
  }
  .el-table__fixed-right-patch {
    // background-color: #152345 !important; //如果表头有背景色，在这里添加即可
  }
 
 //表格内容处
 .el-table td:last-child {
    border-right: none;
  }
```

最后的效果就是这样啦，没有什么特别好的方法，如果你有的话留言一下呗。

![img](https://img-blog.csdnimg.cn/ca21fa3a1f024787a5c376fabe7a97b2.png)

------

# 提高样式优先级

!important

```css
.ant-tabs-extra-content {
  float: left !important;
  position: absolute;
}
```



------

# Vue项目中的接口调用

在企业开发过程中，往往有着明确的前后端的分工，前端负责接收、使用接口，后端负责编写、处理接口。

对于前端如何使用接口，今天在Vue中进行讲解。

一个项目往往由这几个部分组成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e07ffc1875ba4431ba4974453ba194e7.png)

其中在src文件夹中，有这么些内容。

![在这里插入图片描述](https://img-blog.csdnimg.cn/ce69167d478b41d3919513a6c6bfef1e.png)

我们常常把接口文件，新建一个文件夹在src下，命名为[api](https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020)，api内的文件便是接口文件。

![在这里插入图片描述](https://img-blog.csdnimg.cn/4d0e8e7cb6314c8c9fc9525a3f89d1a1.png)

通常把后端的接口写在api文件夹下，自己命名为xxx.js

```js
// 登录
export function login(data) {
  return request({
    url: '/api/court/login',
    method: 'post',
    data
  })
}
// 获取验证码
export function captchaImage(params) {
  return request({
    url: '/api/captchaImage',
    method: 'get',
    params
  })
}

```

对于需要添加信息在头部的，可以这么写

```js
// 获取登录用户信息
export function getInfo(params) {
  return request({
    url: '/api/court/getInfo',
    method: 'get',
    params,
    headers: {
      'Authorization': JSON.parse(localStorage.Authorization)
  }
  })
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d175abf6010243b7af7829fa2d3792c7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

这个就是request.js 文件的内容

![在这里插入图片描述](https://img-blog.csdnimg.cn/1729607db8c34869ba4c78b8fd797eb3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_18,color_FFFFFF,t_70,g_se,x_16)

```js
import axios from 'axios'
// import { getToken } from '@/utils/auth'

// create an axios instance
const service = axios.create({
  // 外网更新
  // baseURL: 'http://xxxxx',
  baseURL: '/xxxxx',  
  timeout: 5000 // request timeout
})

export default service

```

项目的页面往往写在views中，每个页面设一个文件夹，其中index.vue 内容则是本页面的内容

![在这里插入图片描述](https://img-blog.csdnimg.cn/e1bef25f73ea4d8094ab678fb94d6757.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

在页面中，如果我们需要使用某个接口。则需要进行引入操作。通过 import {接口名1、接口名2} from ’ api文件地址 ’

```js
import { login,captchaImage,getInfo,logOut,reset } from '@/api/login'

```

from后所跟的就是api中文件的地址路径

接口往往是在方法中进行调用，对于不同接口 ，需要的参数也不一样，根据需求，我们传入对应的参数即可。图中的 captchaImage、以及login就是接口信息。

接口的使用格式：

接口名({参数1:页面中的参1，参数2：页面中的参数2}).then(res => {
console.log(res)//res就是调用接口后，后台返回过来的结果，一般数据储存在res.data.data中，具体情况而论

![在这里插入图片描述](https://img-blog.csdnimg.cn/de131c8dd9614722a3c46827d13504ca.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

这样就是接口调用的全部过程了。附上控制台信息图以及apipost接口图。

![在这里插入图片描述](https://img-blog.csdnimg.cn/14c65c554a8e4263b5ffc1edb29f1efc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/e35ac014af244b939d8495d09566ef43.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/f2bb9a15ab3d47f29a61c6c53b193813.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR6KaB5b2T5YmN56uv5bel56iL5biI,size_20,color_FFFFFF,t_70,g_se,x_16)

------

# 表格功能

### 效果：

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-02_16-48-50.png)

### 注意1：数据`list`结构

> 第一个 a-form-model 控制表格个数，每次新增会在列表 list 中push一个对象（包含时间和能否编辑，还有一个包含数据"里程、自提、配送左右俩数字"的列表，对象内新增对象），
>
> list：[ { 规则1：时间，[ {规则数据第一行} ] }，{ 规则2 }，{ 规则3 } ]

```js
list：[  { 规则1：时间，[ {规则数据第一行} ，{规则数据第二行}  ] } , { 规则2 } , { 规则3 }  ]

list:[
	{   //规则1
		key: this.$_.uniqueId(),
        edit: true,
        pickTimeBegin: pickTimeBeginMoment.format('HH:mm'),
        pickTimeEnd: pickTimeEndMoment.format('HH:mm'),
        pickTimeBeginMoment,
        pickTimeEndMoment,
        ruleList: [
        	{	//行内数据 第一行
        		key: this.$_.uniqueId(),
        		mileageLeft: '',
        		mileageRight: '',
        		selfDateLeft: '0',
        		selfDateRight: '0',
        		deliveryDateLeft: '0',
        		deliveryDateRight: '0',
      		},
      		{  //第二行
      		...
      		},
        ],
	},
	{  //规则2
	...
	}
]
```

### 注意2：

required是做什么用的:这个是加了后，label前面会有星号,这个不会触发校验

![image-20221103143118213](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143118213.png)

在rules里面配置，也会有星号，但是会触发校验了

![image-20221103143222251](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143222251.png)

### 注意3：时间使用moment来实现

包括现在时间`this.$moment()`，判断末端时间是否在起始时间前：isSameOrAfter()

moment().isSameOrAfter(Moment|String|Number|Date|Array); moment().isSameOrAfter(Moment|String|Number|Date|Array, String);

> 检查一个 moment 是否在另一个 moment 之后或与之相同。 第一个参数会被解析为 moment（如果尚未解析）。

```
moment('2010-10-20').isSameOrAfter('2010-10-19'); // true
moment('2010-10-20').isSameOrAfter('2010-10-20'); // true
moment('2010-10-20').isSameOrAfter('2010-10-21'); // false
```

### 注意4：引用全局函数js来判断是否非空

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-04-58.png)

> 详解查看Vue的`Vue.prototype`详解	

### 注意5：全局提示实现

在main.js中添加全局 ant-design-vue方法组件 message ，然后通过this.$message调用。具体查看ant-design-vue文档

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-27-36.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-40-14.png)

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-39-39.png)

常用方法：（包括成功、失败、警告。

```vue
<template>
  <div>
    <a-button @click="success">
      Success
    </a-button>
    <a-button @click="error">
      Error
    </a-button>
    <a-button @click="warning">
      Warning
    </a-button>
  </div>
</template>
<script>
export default {
  methods: {
    success() {
      this.$message.success('This is a success message');
    },
    error() {
      this.$message.error('This is an error message');
    },
    warning() {
      this.$message.warning('This is a warning message');
    },
  },
};
</script>

```











### 代码：

| allowClear | 是否展示清除按钮      | boolean | true                  |
| ---------- | --------------------- | ------- | --------------------- |
| openChange | 面板打开/关闭时的回调 |         | (open: boolean): void |

```vue
<!-- 里程区间组件 -->
<template>
  <div class="config">
    <a-button v-if="isPlan" type="primary" class="config-add" @click.stop="addForm">新增规则</a-button>
    <a-form-model v-for="(item, index) in list" :key="item.key" labelAlign="left" class="config-form">
      <template v-if="isPlan">
        <a v-if="list.length > 1" class="config-form-delete delete-icon" @click.stop="list.splice(index, 1)" />
        <a-form-model-item label="下单时间" :required="true">
          <a-time-picker v-model="item.pickTimeBeginMoment" format="HH:mm" :allowClear="false"
                         @change="changePickTime(item)" />
          <span class="config-form-interval all-center">~</span>
          <!-- 第一个disabledHours是组件的禁用API，第二个是调用事件 -->
          <a-time-picker v-model="item.pickTimeEndMoment" format="HH:mm" :allow-clear="false"
                         :disabledHours="() => disabledHours(item)" :disabledMinutes="() => disabledMinutes(item)"
                         @openChange="changePickTime(item)" />
        </a-form-model-item>
      </template>
      <template v-if="item.edit">
        <a-button type="primary" @click.stop="addRule(item)">添加里程区间</a-button>
        <template v-if="isPlan || isInventoryEdit">
          <a-button type="primary" @click.stop="saveRule(item, index)">保存</a-button>
          <a-button v-if="!$isEmpty(data[index]) && !$isEmpty(data[index].ruleList)"
                    @click.stop="cancelRule(item, index)">
            取消
          </a-button>
        </template>
      </template>
      <a-button v-else key="edit" type="primary" @click.stop="item.edit = true">修改</a-button>
      <a-table :columns="columns" :dataSource="item.ruleList" :bordered="true" :pagination="false">
        <template slot="mileage" slot-scope="text, record, rowIndex">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.mileageLeft" :min="0" />
              &nbsp;&nbsp;&lt;&nbsp;&nbsp;里程&nbsp;&nbsp;≤&nbsp;&nbsp;
              <a-input-number v-model="record.mileageRight" :min="0" />
            </template>
            <template v-else>
              {{ record.mileageLeft }}
              <template v-if="!$isEmpty(record.mileageLeft)">&lt;&nbsp;&nbsp;</template>
              <span>里程</span>
              <template v-if="!$isEmpty(record.mileageRight)">&nbsp;&nbsp;≤</template>
              {{ record.mileageRight }}
            </template>
            <a v-if="item.edit && item.ruleList.length > 1" class="config-row-delete delete-icon"
               @click.stop="item.ruleList.splice(rowIndex, 1)" />
          </div>
        </template>
        <template slot="since" slot-scope="text, record">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.selfDateLeft" :min="0"
                              @blur.stop="numberInputBlur(record, 'selfDateLeft')" />
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                <a-input-number v-model="record.selfDateRight" :min="0"
                                @blur.stop="numberInputBlur(record, 'selfDateRight')" />
              </template>
            </template>
            <template v-else>
              {{ record.selfDateLeft }}
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                {{ record.selfDateRight }}
              </template>
            </template>
          </div>
        </template>
        <template slot="delivery" slot-scope="text, record">
          <div class="all-center">
            <template v-if="item.edit">
              <a-input-number v-model="record.deliveryDateLeft" :min="0"
                              @blur.stop="numberInputBlur(record, 'deliveryDateLeft')" />
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                <a-input-number v-model="record.deliveryDateRight" :min="0"
                                @blur.stop="numberInputBlur(record, 'deliveryDateRight')" />
              </template>
            </template>
            <template v-else>
              {{ record.deliveryDateLeft }}
              <template v-if="isPlan">
                &nbsp;&nbsp;~&nbsp;&nbsp;
                {{ record.deliveryDateRight }}
              </template>
            </template>
          </div>
        </template>
      </a-table>
    </a-form-model>
  </div>
</template>

<script>
export default {
  name: 'ruleConfig',
  props: {
    data: {
      type: Array,
      default: () => [],
    },
    type: { // 0：计划判断，1：库存配置新增、2：库存配置修改
      type: String,
      default: '0',
    },
  },
  data() {
    return {
      list: [],
      columns: [
        { title: '里程区间（公里）', width: 300, scopedSlots: { customRender: 'mileage' } },
        { title: '自提（计划提货日期+ x 天）', width: 300, scopedSlots: { customRender: 'since' } },
        { title: '配送（期望到货日期-x 天）', width: 300, scopedSlots: { customRender: 'delivery' } },
      ],
    };
  },
  computed: {
    isPlan() {
      return this.type === '0';
    },
    isInventoryEdit() {
      return this.type === '2';
    },
  },
  methods: {
    init() {
      if (this.$isEmpty(this.data)) {
        this.addForm();
      } else {
        this.list = this.data.map(item => ({
          ...item,
          key: item.id || this.$_.uniqueId(),
          edit: item.edit || this.$isEmpty(item.ruleList),
          mileageLeft: this.$isEmpty(item.mileageLeft) ? '' : parseFloat(item.mileageLeft),
          mileageRight: this.$isEmpty(item.mileageRight) ? '' : parseFloat(item.mileageRight),
          pickTimeBeginMoment: this.$moment(item.pickTimeBegin, 'HH:mm'),
          pickTimeEndMoment: this.$moment(item.pickTimeEnd, 'HH:mm'),
          ruleList: item.edit ? item.ruleList : this.initRuleList(item.ruleList),
        }));
      }
    },
    initRuleList(ruleList) {
      return ruleList.map(item => {
        const [selfDateLeft, selfDateRight] = item.selfDate?.toString()?.split('-') || ['0', '0'];
        const [deliveryDateLeft, deliveryDateRight] = item.deliveryDate?.toString()?.split('-') || ['0', '0'];

        return {
          ...item,
          key: item.id || this.$_.uniqueId(),
          selfDateLeft,
          selfDateRight,
          deliveryDateLeft,
          deliveryDateRight,
        };
      });
    },
    addForm() { //增加规则
      const pickTimeBeginMoment = this.$moment();
      const pickTimeEndMoment = this.$moment().add(1, 'h');
      const item = {
        key: this.$_.uniqueId(),
        edit: true,
        pickTimeBegin: pickTimeBeginMoment.format('HH:mm'),
        pickTimeEnd: pickTimeEndMoment.format('HH:mm'),
        pickTimeBeginMoment,
        pickTimeEndMoment,
        ruleList: [],
      };
      this.addRule(item); //增加规则内的行数
      this.list.push(item); //规则并入 list列表
    },
    disabledHours(item) {	// 禁用起始时间之前的小时选项
      const hours = item.pickTimeBeginMoment.hours();
      const disabled = [];	// 禁用列表
      for (let i = 0; i < hours; i++) {
        disabled.push(i);
      }

      if (item.pickTimeBeginMoment.minutes() === 59) {
        disabled.push(hours);
      }

      return disabled;
    },
    disabledMinutes(item) {
      if (item.pickTimeBeginMoment.hours() === item.pickTimeEndMoment.hours()) {
        const disabled = [];
        for (let i = 0; i < item.pickTimeBeginMoment.minutes() + 1; i++) {
          disabled.push(i);
        }

        return disabled;
      }

      return [];
    },
    changePickTime(item) {  	// 每次下单时间变化引发事件判断是否末端时间小于起始时间
      if (item.pickTimeBeginMoment.isSameOrAfter(item.pickTimeEndMoment)) {
        item.pickTimeEndMoment = this.$moment(item.pickTimeBeginMoment).add(1, 'h');	// 若末端时间小于起始时间，则 末时间等于起始加1，使用moment的add必须用 moment().add() 语法
      }
      item.pickTimeBegin = item.pickTimeBeginMoment.format('HH:mm');	// 同样也要更改pickTimeBegin的值
      item.pickTimeEnd = item.pickTimeEndMoment.format('HH:mm');
    },
    numberInputBlur(item, key) {
      if (this.$isEmpty(item[key])) {
        item[key] = 0;
      }
    },
    addRule(item) {  	// 默认规则第一行数据
      item.ruleList.push({
        key: this.$_.uniqueId(),
        mileageLeft: '',
        mileageRight: '',
        selfDateLeft: '0',
        selfDateRight: '0',
        deliveryDateLeft: '0',
        deliveryDateRight: '0',
      });
    },
    saveRule(item) {	// 保存事件
      if (this.checkRule(item.ruleList)) {	// 判断
        item.ruleList = item.ruleList.map(item => ({
          ...item,
          selfDate: this.isPlan ? `${item.selfDateLeft}-${item.selfDateRight}` : item.selfDateLeft,
          deliveryDate: this.isPlan ? `${item.deliveryDateLeft}-${item.deliveryDateRight}` : item.deliveryDateLeft,
        }));

        if (this.$dataType.isFunction(this.$listeners.onSave)) {
          this.$emit('onSave', item.ruleList, () => {
            item.edit = false;
            this.$emit('update:data', this.list);
          });
        } else {
          item.edit = false;
          this.$emit('update:data', this.list);
        }
      }
    },
    checkRule(ruleList) {	// 
      const { length } = ruleList;

      for (let i = 0; i < length; i++) {	// 循环当前规则的每一行数据
        const { mileageLeft, mileageRight } = ruleList[i];	// 赋值解构出 里程左值和右值
        const hasNotMileageLeft = this.$isEmpty(mileageLeft);	// 判断是否为空，空true
        const hasNotMileageRight = this.$isEmpty(mileageRight); // 同上

        if (hasNotMileageLeft && hasNotMileageRight) {	// 若同时为空值则弹出报错返回给saveRule事件false
          this.$message.warning('请输入里程最小值或里程最大值');
          return false;
        }

        if (!hasNotMileageLeft && !hasNotMileageRight && mileageLeft >= mileageRight) { 
          this.$message.warning('里程最小值不能大于或等于里程最大值');
          return false;
        }

        const $mileageLeft = this.$isEmpty(mileageLeft) ? -window.Infinity : mileageLeft + 1;
        const $mileageRight = this.$isEmpty(ruleList[i].mileageRight) ? window.Infinity : mileageRight;
        for (let j = 0; j < length; j++) {
          const _mileageLeft = this.$isEmpty(ruleList[j].mileageLeft) ? -window.Infinity : ruleList[j].mileageLeft + 1;
          const _mileageRight = this.$isEmpty(ruleList[j].mileageRight) ? window.Infinity : ruleList[j].mileageRight;

          if (i !== j && Math.max($mileageLeft, _mileageLeft) <= Math.min($mileageRight, _mileageRight)) {
            this.$message.warning('里程区间不可重复');
            return false;
          }
        }
      }

      return true;
    },
    cancelRule(item, index) {
      item.edit = false;
      item.ruleList = this.initRuleList(this.data[index].ruleList);
    },
    getRuleList() {
      const { length } = this.list;
      for (let i = 0; i < length; i++) {
        if (!this.checkRule(this.list[i].ruleList)) {
          return false;
        }

        const pickTimeBegin = this.$moment(this.list[i].pickTimeBeginMoment.format('HH:mm'), 'HH:mm').valueOf();
        const pickTimeEnd = this.$moment(this.list[i].pickTimeEndMoment.format('HH:mm'), 'HH:mm').valueOf();
        for (let j = 0; j < length; j++) {
          const _pickTimeBegin = this.$moment(this.list[j].pickTimeBeginMoment.format('HH:mm'), 'HH:mm').valueOf();
          const _pickTimeEnd = this.$moment(this.list[j].pickTimeEndMoment.format('HH:mm'), 'HH:mm').valueOf();

          if (i !== j && Math.max(pickTimeBegin, _pickTimeBegin) <= Math.min(pickTimeEnd, _pickTimeEnd)) {
            this.$message.warning('时间区间不可重复');
            return false;
          }
        }
      }

      return this.list;
    },
  },
  watch: {
    data: {
      immediate: true,
      handler() {
        this.init();
      },
    },
  },
};
</script>

<style lang="scss" scoped>
.config {
  .ant-btn {
    min-width: 68px;
    font-size: 12px;
    margin-bottom: 12px;

    &.config-add {
      width: 102px;
    }

    &:not(.ant-btn-primary) {
      background-color: transparent;
    }

    & + .ant-btn {
      margin-left: 8px;
    }
  }

  .config-form {
    position: relative;
    padding: 16px;
    background-color: #f7f7f7;

    & + .config-form {
      margin-top: 8px;
    }

    .delete-icon {
      position: absolute;
      z-index: 1;
      width: 16px;
      height: 16px;

      &.config-form-delete {
        top: 24px;
        right: 17px;
        background: url(../../assets/imager/delete_red_close.png) no-repeat;
        background-size: 100% 100%;
      }

      &.config-row-delete {
        top: 50%;
        left: 10px;
        background: url(../../assets/imager/delete_red_minus.png) no-repeat;
        background-size: 100% 100%;
        transform: translate(0, -50%);
      }
    }

    .ant-time-picker {
      width: 112px;
    }

    .config-form-interval {
      display: inline-flex;
      width: 16px;
    }

    /deep/ .ant-form-item-label {
      width: 94px;

      label {
        color: #333;
        font-size: 14px;
      }
    }

    /deep/ .ant-table {
      .ant-table-thead {
        th {
          height: 30px;
          text-align: center !important;
          padding: 0;
          border-bottom: none;
          background-color: #f7f7f7 !important;
        }
      }

      .ant-table-tbody {
        td {
          position: relative;
          height: 52px;
          border-color: #d8d8d8;
          border-bottom: none;
          background-color: #fff;
          box-shadow: inset 0px -1px 0 0 #d9d9d9;
        }
      }
    }
  }
}
</style>

```

判断是否为空：

```js
// 判断是否为空
export const isEmpty = value => {
  switch (dataType.getType(value)) {
    case 'Set':
    case 'Map':
      return value.size === 0;
    case 'Object':
      return Object.keys(value).length === 0;
    case 'Array':
      return value.length === 0;
    default:
      return ['', null, undefined].includes(value);
  }
};

// 获取数据类型
const getType = value => Object.prototype.toString.call(value).slice(8, -1);

// 数据类型操作
export const dataType = {
  getType,
  isMap: value => getType(value) === 'Map',
  isSet: value => getType(value) === 'Set',
  isObject: value => getType(value) === 'Object',
  isArray: value => getType(value) === 'Array',
  isFunction: value => getType(value) === 'Function',
  isDate: value => getType(value) === 'Date',
  isReg: value => getType(value) === 'RegExp',
  isString: value => getType(value) === 'String',
  isNumber: value => getType(value) === 'Number',
  isBoolean: value => getType(value) === 'Boolean',
  isNull: value => getType(value) === 'Null',
  isUndefined: value => getType(value) === 'Undefined',
};
```

message弹窗

> 使用的是ant-design-vue的message组件

![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2022-11-04_15-27-36.png)









------

# 实现星号

required是做什么用的:这个是加了后，label前面会有星号,这个不会触发校验

![image-20221103143118213](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143118213.png)

在rules里面配置，也会有星号，但是会触发校验了

![image-20221103143222251](C:\Users\shizeyu\AppData\Roaming\Typora\typora-user-images\image-20221103143222251.png)

------

# 截取片段

```js
const data = r.data;
const startIndex = data.indexOf('window');
const endIndex = data.lastIndexOf('window');
console.log(JSON.parse(r.data.substring(startIndex + 17, endIndex - 18)));
```

## substring字符串截取

https://blog.csdn.net/way343922/article/details/122084066

## js的indexOf方法

https://blog.csdn.net/Smile_666666/article/details/119595672





------

# LNG窗口期

```
data: JSON.stringify({
            "UserName": "",
            "Code": ""
        }),


data: {
            "UserName": "",
            "Code": ""
        },
```

```js
export default {
  data() {
    return {
      // 定义一个变量来保存请求结果
      result: null
    };
  },
  created() {
    this.sendRequest();
  },
  methods: {
    sendRequest() {
      // 发送 HTTP 请求
      axios.get('/some/api')
        .then((response) => {
          // 如果请求成功，更新 result 的值
          this.result = response.data;

          // 如果 result 的值不等于预期值，再次发送请求
          if (this.result !== 'expected value') {
            this.sendRequest();
          }
        })
        .catch((error) => {
          // 如果请求失败，提示错误信息
          console.error(error);
        });
    }
  }
}

```

```js
 getChinagqpgxCtl() {
       getChinagqpgxCtl().then(response => {
         this.list = this.parsingData(response.data.results?.data || []);
         const date = this.list[0]?.createDate;

         if (!this.$isEmpty(date)) {
           this.date = this.$moment(
             `${date.substring(0, 4)}/${date.substring(4, 6)}/${date.substring(6, 8)}`
           );
         }
       });
     },
     getChinagqpgxCtlDate() {
       console.log({ createDate: this.dateFormat });
       getChinagqpgxCtlDate({ createDate: this.dateFormat }).then(response => {
         this.list = this.parsingData(response.data.results?.data || []);
       });
     },
```

