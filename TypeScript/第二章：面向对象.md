# 第二章：面向对象

面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，<font color='gree'>简而言之就是程序之中所有的操作都需要通过对象来完成</font>。

- 举例来说：
  - 操作浏览器要使用window对象
  - 操作网页要使用document对象
  - 操作控制台要使用console对象

一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的<font color='gree'>抽象</font>，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。<font color='gree'>程序也是对事物的抽象</font>，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。

在程序中所有的对象都被分成了两个部分<font color='gree'>数据和功能</font>，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。<font color='gree'>数据在对象中被成为属性，而功能就被称为方法</font>。<font color='gree'>所以简而言之，在程序中一切皆是对象</font>。

## 1、类（class）

要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，<font color='gree'>所谓的类可以理解为对象的模型</font>，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。

- 定义类：

  - ```typescript
    class 类名 {
    	属性名: 类型;
    	
        // constructor 被称为构造函数
        // 构造函数会在对象创建时调用
    	constructor(参数: 类型){
            // 在实例方法中，this 就表示当前创建的的实例
            // 在构造函数中当前对象就是当前新建的那个对象
            // 可以通过 this 向新建的对象中添加属性
    		this.属性名 = 参数;
    	}
    	
    	方法名(){
    		....
    	}
    
    }
    
    --------------------------------------
    // 在学习完修饰符后，可以使用另一种写法来简便定义类，不再需要定义属性
    class Person{
        
      // 可以直接将属性定义在构造函数中
      constructor(public name: string, public age: number){
      }
    
      sayHello(){
          console.log(`大家好，我是${this.name}`);
      }
    }
    ```

- 示例：

  - ```typescript
    class Person{
        name: string;
        age: number;
    
        constructor(name: string, age: number){
            this.name = name;
            this.age = age;
        }
    
        // 定义方法
        sayHello(){
            console.log(`大家好，我是${this.name}`);
        }
    }
    
    -----------------------------
    
    class Person{
        name: string = '孙悟空';
        age: number = 18;
    }
    ```

- 使用类：

  - ```typescript
    const p = new Person('孙悟空', 18);
    p.sayHello();
    
    --------------------
    const p = new Person();
    console.log(p.number)
    ```

## 2、面向对象的特点

- 封装

  - <font color='gree'>对象实质上就是属性和方法的容器</font>，它的主要作用就是存储属性和方法，这就是所谓的封装

  - 默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置

  - <font color='gree'>只读属性（readonly）</font>：

    - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改

    - ```typescript
      class Person{
          readonly name: string;
          readonly age: number;
      }
      ```

  - <font color='gree'>TS中属性具有三种修饰符</font>：(在属性前)

    - <font color='red'>public（默认值）</font>，公共属性，可以在任意位置访问修改，类、<font color='red'>子类</font>和对象中修改
    - <font color='red'>protected </font>，受包含的属性，只能在当前类、子类内部中进行访问（修改）
    - <font color='red'>private </font>，私有属性，只能在类内部中访问（修改），<font color='gree'>子类内部不行</font>

  - 示例：

    - <font color='red'>public</font>

      - ```typescript
        // 现在属性是在对象设置的。属性可以任意的被修改，属性可以任意被修改将会导致对象中的数据变得非常不安全
        class Person{
            public name: string; // 写或什么都不写都是public
            public age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以在类中修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 可以通过对象修改
        ```

    - <font color='red'>protected</font>

      - ```typescript
        class Person{
            protected name: string;
            protected age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
            
            test(){
                console.log(this.name); // 可以访问
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

    - <font color='red'>private</font>

      - ```typescript
        class Person{
            private name: string;
            private age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中不能修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

  - <font color='gree'>属性存取器</font>

    - 对于一些不希望被任意修改的属性，可以将其设置为`private`

    - 直接将其设置为`private`将导致<font color='gree'>无法再通过对象修改其中的属性</font>

    - 我们可以<font color='gree'>在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的<font color='red'>存取器</font></font>

    - <font color='gree'>读取属性的方法叫做<font color='red'>`setter`</font>方法，设置属性的方法叫做<font color='red'>`getter`</font>方法</font>

    - 存取器的意义：private实现属性的私有化，存取器实现对属性操作的限制

    - 示例：

      - ```typescript
        class Person{
            private _name: string;
        
            constructor(name: string){
                this._name = name;
            }
        		
            // TS 中设置 getter 方法的方式
            get name(){
                return this._name;
            }
        
            // TS 中设置 setter 方法的方式
            // set 只能有一个参数
            set name(name: string){
                this._name = name;
            }
        
            // 定义方法，用来设置name属性 与上面的方法效果一样，所以还是推荐上面的方法
            // getname(){
            // 		return this._name;
        	// }
            // // 定义方法，用来获取name属性 与上面的方法效果一样，所以还是推荐上面的方法
            // setname(name: string){
            // 		this._name = name;
        	// }
        }
        
        const p1 = new Person('孙悟空');
        console.log(p1.name); // 通过getter读取name属性
        p1.name = '猪八戒'; // 通过setter修改name属性
        
        // console.log(p1.getname());
        // p1.setname('zhubajie');
        ```

  - <font color='gree'>静态属性</font>

    - 静态属性（方法），也称为<font color='gree'>类属性</font>。使用静态属性<font color='gree'>无需创建实例</font>，通过类即可直接使用

    - 静态属性（方法）使用static开头

    - 示例：

      - ```typescript
        class Tools{
            static PI = 3.1415926;
            
            static sum(num1: number, num2: number){
                return num1 + num2
            }
        }
        
        console.log(Tools.PI);
        console.log(Tools.sum(123, 456));
        ```

  - <font color='gree'>this</font>

    - <font color='gree'>在类中，使用this表示当前对象</font>

- <font color='gree'>继承</font>

  - 继承时面向对象中的又一个特性

  - 通过继承可以将其他类中的属性和方法引入到当前类中

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        }
        
        /*	Dog extends Animal
        *	此时，Animal 被称为父类，Dog被称为子类
        *	使用继承后，子类将会拥有父类所有的方法和属性
        *	通过继承可以将多个类中共有的代码写在一个父类中，
        *		这样只需要写一次即可让所有的子类都同时拥有父类中的属性和方法
        *		如果希望扩展，那在子类内加就行
        *	-如果在子类中添加了子和父类相同的方法，则子类方法会覆盖掉父类的方法
        *	-这种子类覆盖父类方法的形式，我们称为方法重写
        */
        
        // 定义一个表示狗的类
        // 使 Dog 类继承 Animal 类
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```
  
  - <font color='gree'>通过继承可以在不修改类的情况下完成对类的扩展</font>
  
  - <font color='red'>重写</font>
  
    - <font color='gree'>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</font>
  
    - 示例1： 重写<font color='red'>方法</font>的情况
  
      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        
            run(){
                console.log(`子类中的run方法，会重写父类中的run方法！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```
  
      - 在子类中可以使用super来完成对父类的引用
      
        > 为什么要用 super()
  
    - 示例2: <font color='gree'>重写属性的话</font>
  
      - ```typescript
        // 父
        class Animal{
            name: string;
        
            constructor(name: string){
                this.name = name;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        // 子
        
        // 报错，如下图一
        // 原因：子内重写了`constructor`构造函数，故而父内的constructor失效，原有的属性声明失效
        class Dog extends Animal{
        
            age: number;
        
            constructor(name: string, age: number){
                this.age = age;
            }
        }
        
        // 正确调用
        class Dog extends Animal{
        
            age: number;
        
            constructor(name: string, age: number){
                // 同样加上name的属性传参
                surper(name);	// 调用父类的构造函数，且super必须写在其他子类重写代码前
                this.age = age;
            }
        }
        
        
        
        // 调用
        const dog = new Dog('旺财', 4);
        ```
  
        ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-11-10_15-51-16.jpg)
  
        ```
        
        ```
  
        
  
  - <font color='gree'>抽象类（abstract class）</font>
  
    - 抽象类是<font color='gree'>专门用来被其他类所继承的类</font>，它只能被其他类所继承<font color='gree'>不能用来创建实例</font>
  
    - ```typescript
      /*
      *	以abstract开头的类是抽象类，
      *		抽象类和其他类区别不大，只是不能用来创建对象
      *		抽象类就是专门用来被继承的类
      * */
      abstract class Animal{
          // 定义一个抽象方法
          // 抽象方法使用 abstract 开头，没有方法体
          // 抽象方法只能放在抽象类中，子类必须对抽象方法进行重写
          abstract run(): void;
          // 公用方法 bark()
          bark(){
              console.log('动物在叫~');
          }
      }
      
      class Dog extends Animals{
          // 重写 run()
          run(){
              console.log('狗在跑~');
          }
      }
      ```
      
    - <font color='gree'>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</font>
    
    

## 3、接口（Interface）

接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。

> <font color='gree'>相当于 抽象类是半抽象的，不一定有抽象方法属性。接口是完全抽象的，方法和属性必须是抽象的</font>
>
> <font color='gree'>接口可以看作是一种规范</font>

- 示例（检查对象类型）：

  - ```typescript
    interface Person{
        name: string;
        sayHello():void;
    }
    
    function fn(per: Person){
        per.sayHello();
    }
    
    fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});
    
    ```

- 示例（实现）

  - ```typescript
    /*
    *	接口可以在定义类的时候限制类的结构
    *		接口中所有的属性都不能有实际的值
    *		接口只定义对象的结构，而不考虑值
    *		在接口中所有的方法都是抽象方法
    */
    interface Person{
        name: string;
        sayHello():void;
    }
    
    /*
    *	定义类时候，可以使类去实现接口
    *		实现接口就是满足接口的规范
    */
    class Student implements Person{
        constructor(public name: string) {
        }
    
        sayHello() {
            console.log('大家好，我是'+this.name);
        }
    }
    ```
    

- 示例:<font color='gree'>当成类型使用</font>（创造对象）

  - ```typescript
    /*
    *	接口用来定义一个类的结构，用来定义一个类中应该包含哪些属性和方法
    *		同时也可以当成 类型声明去使用
    */
    interface myType{
        name: string;
        age: number;
    }
    
    // 建立一个实例对象
    const obj: myType = {
        name: 'sss',
        age: 19,
    }
    
    ```

    ```typescript
    /*
    *	与类型对象 type 不同，同一个接口可以反复声明
    *		声明同一个接口，他们的属性会叠加
    */
    interface myType{
        name: string;
        age: number;
    }
    
    interface myType{
        gender: string;
    }
    
    // 建立一个实例对象
    const obj: myType = {
        name: 'sss',
        age: 19,
        gender: 'adcad'
    }
    
    ```

    ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-11-11_14-53-06.jpg)




## 4、泛型（Generic）

定义一个<font color='greree'>函数或类</font>时，有些情况下无法确定其中要使用的<font color='gree'>具体类型（返回值、参数、属性的类型不能确定）</font>，此时泛型便能够发挥作用。

> <font color='greree'>泛型是把类型也作为参数传递，这样在定义时可以把类型也动态化</font>

- 举个例子：

  - ```typescript
    function test(arg: any): any{
    	return arg;
    }
    ```

  - 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先<font color='greree'>使用any会关闭TS的类型检查</font>，其次这样设置也不能体现出参数和返回值是相同的类型

  

  - 使用泛型：

  - ```typescript
    function test<T>(arg: T): T{
    	return arg;
    }
    ```

  - <font color='gree'>这里的```<T>```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型</font>。

  - 那么如何使用上边的函数呢？

    - <font color='red'>方式一</font>（直接使用）：

      - ```typescript
        test(10)
        ```

      - 使用时可以直接传递参数使用，<font color='greree'>类型会由TS自动推断出来，也就相当于给泛型传递了类型</font>，但有时编译器无法自动推断时还需要使用下面的方式

    - <font color='red'>方式二</font>（指定类型）：

      - ```typescript
        test<number>(10)
        ```

      - 也可以在函数后手动指定泛型

  - 可以同时指定多个泛型，泛型间使用逗号隔开：

    - ```typescript
      function test<T, K>(a: T, b: K): K{
          return b;
      }
      
      test<number, string>(10, "hello");
      ```

    - <font color='gree'>使用泛型时，完全可以将泛型当成是一个普通的类去使用</font>

  - <font color='red'>类</font>中同样可以使用泛型：

    - ```typescript
      class MyClass<T>{
          prop: T;
      
          constructor(prop: T){
              this.prop = prop;
          }
      }
      
      const mc = new MyClass<string>('abbb')
      ```

  - 除此之外，也可以对泛型的范围进行约束

    - ```typescript
      interface MyInter{
          length: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length;
      }
      
      // 传过去的值要要符合规范，传过去的值都会视为对象
      test({length: 10,});
      test('100');   // 在这里 字符串100是可以的，因为 字符串 和 数组默认自带 length这个属性，恰好名字相同
      
      
      ----------------------------------
      interface MyInter1{
          length1: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length1;
      }
      
      test('100');   // 报错了，因为没有 length1 属性
      ```
      
    - <font color='gree'>使用`T extends MyInter`表示泛型`T`必须是`MyInter`的`子类`，不一定非要使用<font color='greree'>接口类</font>和<font color='greree'>抽象类</font>同样适用</font>。

    - 





