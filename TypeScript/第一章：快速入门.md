# 第一章 快速入门

https://blog.csdn.net/weixin_36038649/article/details/123864631

## 0、TypeScript简介

1. TypeScript是JavaScript的超集。
2. 它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。
3. TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。
4. TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。
5. 相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。



## 1、TypeScript 开发环境搭建

1. 下载Node.js
   - 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi
   - 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi
   
2. 安装Node.js

3. 使用npm全局安装typescript
   - 进入命令行
   - 输入：npm i -g typescript
   
4. 创建一个ts文件

5. 使用tsc对ts文件进行编译
   - 进入命令行
   
   - 进入ts文件所在目录
   
   - 执行编译命令：tsc xxx.ts
   
     

## 2、基本类型

- 类型声明

  - 类型声明是TS非常重要的一个特点

  - 通过类型声明可以指定TS中变量（参数、形参）的类型

  - <font color='gree'>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</font>

  - 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值

  - 语法：

    - ```typescript
      // 1.声明类型
      let 变量: 类型;
      eg: let a: string;
      
      // 2.声明赋值
      let 变量: 类型 = 值;
      eg: let a: number = 100;
      
      // 3.声明函数
      // 入参1 类型、入参2 类型、 返回值 类型
      function fn(参数: 类型, 参数: 类型): 类型{
          ...
      }
      
      function fn = (参数: 类型, 参数: 类型): 类型 => {
          ...
      }
          
      //另一种函数类型
          // 单独分别指定参数、返回值的类型 `(num1: number, num2: number) => number` 是单独一部分
          function add: (num1: number, num2: number) => number = (num1, num2) => {
              ...
          }
              
      
      // 4.直接赋值（自动检测类型）
      // 如果变量的声明和赋值是同时进行的，TS可以自动对变量进行类型检测
      let c = false;  // 类型推测自动归为 boolean
      
      c = 100;  // 报错
         
          
      // 5.直接使用字面量声明 (类似于常量)
      let a: 10;
      let c: true;
      let b: 'hello';
          
      a = 10;
      a = 11; // 报错
          
      // 6.联合类型 （可以使用 | 来连接多个类型）
      let b: "hello" | "hi"; // 可以 b = "hello" 也可以 b = "hi"
      let c: boolean | string;
      c = true;
      c = 'hello';
      ---------------------------
          
          
      ```

- 自动类型判断

  - TS拥有自动的类型判断机制
  - <font color='gree'>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</font>
  - 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明


### 类型：

|             类型              |            例子             |                描述                |
| :---------------------------: | :-------------------------: | :--------------------------------: |
|            number             |         1, -33, 2.5         |              任意数字              |
|            string             |      'hi', "hi", `hi`       |             任意字符串             |
|            boolean            |         true、false         |         布尔值true或false          |
|            字面量             |           其本身            |    限制变量的值就是该字面量的值    |
| <font color='gree'>any</font> | <font color='gree'>*</font> | <font color='gree'>任意类型</font> |
|            unknown            |              *              |           类型安全的any            |
|             void              |      空值（undefined）      |       没有值（或undefined）        |
|             never             |     没有值(连空都没有)      |            不能是任何值            |
|            object             |       {name:'孙悟空'}       |            任意的JS对象            |
|             array             |           [1,2,3]           |             任意JS数组             |
|         tuple   元组          |            [4,5]            |   元素，TS新增类型，固定长度数组   |
|          enum  枚举           |         enum{A, B}          |         枚举，TS中新增类型         |

#### number

- ```typescript
  let decimal: number = 6;
  let hex: number = 0xf00d;
  let binary: number = 0b1010;
  let octal: number = 0o744;
  let big: bigint = 100n;
  ```

#### boolean

- ```typescript
  let isDone: boolean = false;
  ```

#### string

- ```typescript
  let color: string = "blue";
  color = 'red';
  
  let fullName: string = `Bob Bobbington`;
  let age: number = 37;
  let sentence: string = `Hello, my name is ${fullName}.
  
  I'll be ${age + 1} years old next month.`;
  ```

#### 字面量

- 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围

- ```typescript
  let color: 'red' | 'blue' | 'black';
  let num: 1 | 2 | 3 | 4 | 5;
  
  const str2 = 'hello Ts'  // 变量 str2 的类型为：'Hello TS'
  // str2 是一个常量（const），它的值不能变化只能是 'Hello TS'，所以，它的类型为：'Hello TS
  
  // 对象字面量详看 object部分
  ```

#### any

- ```typescript
  let d: any = 4;
  d = 'hello';
  d = true;
  
  // 隐性 any
  // 如果在TS中定义了变量没规定类型，ts编辑器自动规定为 any , 避免这种情况出现！！！
  let a;
  
  // 类型污染
  let b : any;
  b = false;
  let a : number;
  a = b; // any会污染
  ```

#### unknown

- ```typescript
  let notSure: unknown = 4;
  notSure = 'hello';
  notSure = true;
  
  // unknown 表示未知类型的值
  // unknown 的变量，不能直接赋值给其他变量
  ```
  
  ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-10-26_16-43-23.jpg)
  
  > 可以通过判断类型后赋值给其他变量
  
  ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-10-26_16-47-09.jpg)
  
  > 或者<font color='gree'>类型断言</font>
  
  ```typescript
  /*
  * 语法：
  *	变量 as 类型
  *	<类型>变量
  */
  
  
  let b : unknown;
  b = 123;
  let a : number;
  
  // 类型断言，可以用来告诉解析器变量的实际类型
  a = b as number;
  a = <number>b;
  ```
  
  

#### void

- ```typescript
  let unusable: void = undefined;
  
  // void 常用于函数返回值，即不返回任何值
  function fn(num): void{
    return;
    return undefined;
    return null;	// 报错
    return 123;	// 报错
  }
  ```

#### never

- ```typescript
  // 连空都没，通常用于报错或死循环
  function error(message: string): never {
    throw new Error(message);
  }
  ```

#### object（几种不同用法）

- ```typescript
  // 没啥用基本不用
  let obj: object = {};
  
  ---------------------------------------------------
  // object 字面量 相关应用（使用较多）
  
  // {} 用来指定对象中可以包含哪些属性
  // 语法: { 属性名: 属性值, 属性名: 属性值 }
  let b: { name: string }; 
  b = { name: '111' };
  b = { name: '111', age: 'xxx' };   //报错，对象字面量只能指定已知内容，不能多也不能少
  
  let a: { name: string; age: number; sayHi(): void } = {
      name: 'jack',
      age: 18,
      sayHi() {}
  }
  ------------------------------------------------------------------
  // 在属性名后要加上 ? ,表示属性是可选的
  let c: { name: string, age?: number };
  c = {name:'hhh'}
  c = {name:'hhh', age: 123}
  
  // [propName: string]: any   表示任意类型的属性
  // [propName: string]: 指定类型   表示指定类型的属性
  let a: {name: string, [propName: string]: any};   // a字面量指定必须有name，以及任意类型的属性
  a = {name: 'aaa'}
  a = { ahe: '11'}   // 报错，没有name
  a = {name: 'aaa', age: 18, niubibu: true}
  
  let a1: {[propName: string]: number};  // a字面量，必须是number的属性
  a1 = {name: 'aaa'}  // 报错，非number
  a1 = { ahe: 111}
  a1 = {name: 111, age: 222}
  
  
  /*
  *    设置函数结构的类型声明：
  *       语法：(形参: 类型, 形参: 类型 ...) => 返回值类型
  * */
  let d: (a: number, b:number) => number;
  d = function (n1: number, n2: number): number{
      return n1+n2;
  }
  
  d = function (n1: number, n2: number, n3: number): number{  //报错  定义参数数量有严格要求
      return n1+n2;
  }
  
  d = function (n1: number, n2: string): number{  //报错  定义参数类型有严格要求
      return n1+n2;
  }
  ```

#### array

- ```typescript
  let list: number[] = [1, 2, 3];
  let list: Array<number> = [1, 2, 3];
  
  /*
  *    类型[]
  *    Array<类型>
  * */
  ```

#### tuple

- ```typescript
  /*
  *    元组
  *    固定长度的数组
  *     语法：[类型，类型，类型]
  * */
  let x: [string, number];
  x = ["hello", 10];  
  x = ["hello", 10, 11];  // 长了报错
  x = ["hello"];  // 短了报错
  ```

#### enum

> <font color='gree'>注意：枚举成员是有值的，默认为：从 0 开始自增的数值。</font>
>
> 我们把，枚举成员的值为数字的枚举，称为：<font color='gree'>数字枚举</font>
>
> 当然，也可以给枚举中的成员初始化值
>
> <font color='gree'>字符串枚举</font>：枚举成员的值是字符串
>
> <font color='gree'>注意：字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值</font>

- ```typescript
  enum Color {
    Red,
    Green,
    Blue,
  }
  let c: Color = Color.Green;  // red 0 green 1 blue 2
  
  //注意：枚举成员是有值的，默认为：从 0 开始自增的数值
  
  
  
  enum Color {
    Red = 1,
    Green,
    Blue,
  }
  let c: Color = Color.Green;
  
  enum Color {
    Red = 1,
    Green = 2,
    Blue = 4,
  }
  let c: Color = Color.Green;
  
  
  // 字符串枚举没有自增长行为，因此，字符串枚举的每个成员必须有初始值
  enum Color {
    Red = '1',
    Green = '2',
    Blue = '4',
  }
  let c: Color = Color.Green;
  ```
  
- 类型断言

  - 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：

    - 第一种

      - ```typescript
        let someValue: unknown = "this is a string";
        let strLength: number = (someValue as string).length;
        ```

    - 第二种

      - ```typescript
        let someValue: unknown = "this is a string";
        let strLength: number = (<string>someValue).length;
        ```


### & 表示同时

> 需要同时满足

```typescript
let j: { name: string } & { age: number };
j = { name: 'sss', age: 18 };
```

### 类型别名

> 简化类型的操作

```typescript
//类型的别名
// 语法：
// type 类型名 = 类型
// type 类型名 = 字面量

type myType = 1 | 2 | 3 | 4;
let k: myType;
let j: myType;
let l: myType;

k = 2;

type myType = string;
let k: myType;
let j: myType;
let l: myType;

k = '2';
```

### 可选参数

使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到可选参数了。 比如，数组的 slice 方法，可以 slice() 也可以 slice(1) 还可以 slice(1, 3)

```typescript
function mysda(start?: number, end?: number): void {
    console.log('')
}
```

可选参数：在可传可不传的参数名称后面添加 ?（问号）。 

<font color='red'>注意：可选参数只能出现在参数列表的最后，也就是说可选参数后面不能再出现必选参数</font>



## 3、编译选项

- 自动编译文件

  - 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。

  - 示例：

    - ```powershell
      tsc xxx.ts -w
      ```

- 自动编译整个项目

  - 如果<font color='gree'>直接使用`tsc`指令，则可以自动将当前项目下的所有ts文件编译为js文件</font>。
  - 但是能直接使用tsc命令的前提时，<font color='gree'>要先在项目根目录下创建一个`ts`的配置文件 `tsconfig.json`</font>
  - tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译
  - <font color='gree'>添加配置文件后，只需只需 `tsc -w`命令即可完成对整个项目的自动监视编译</font>

```
{
 
}
```



- 配置选项：

  - include

    - 定义希望被编译文件所在的目录

    - 默认值：["\*\*/\*"]

    - 示例：

      - ```json
        "include":["src/**/*", "tests/**/*"]
        ```

      - 上述示例中，所有src目录和tests目录下的文件都会被编译

  - exclude

    - 定义需要排除在外的目录

    - 默认值：["node_modules", "bower_components", "jspm_packages"]

    - 示例：

      - ```json
        "exclude": ["./src/hello/**/*"]
        ```

      - 上述示例中，src下hello目录下的文件都不会被编译

  - extends

    - 定义被继承的配置文件

    - 相当于引入外部文件

    - 示例：

      - ```json
        "extends": "./configs/base"
        ```

      - 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息

  - files

    - 指定被编译文件的列表，只有需要编译的文件少时才会用到

    - 示例：

      - ```json
        "files": [
            "core.ts",
            "sys.ts",
            "types.ts",
            "scanner.ts",
            "parser.ts",
            "utilities.ts",
            "binder.ts",
            "checker.ts",
            "tsc.ts"
          ]
        ```

      - 列表中的文件都会被TS编译器所编译

    - <font color='gree'>compilerOptions</font>

      - <font color='gree'>编译选项是配置文件中非常重要也比较复杂的配置选项</font>

      - 在compilerOptions中包含多个子选项，用来完成对<font color='gree'>编译的配置</font>

        - 项目选项

          - <font color='red'>target</font>

            - <font color='gree'>设置ts代码编译的目标版本</font>

            - 可选值：

              - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext (最新)

            - 示例：

              - ```json
                "compilerOptions": {
                    "target": "ES6"
                }
                ```

              - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码

          - <font color='red'>lib</font>

            - <font color='gree'>指定代码运行时所包含的库（宿主环境）</font>

            - 例如`document`所在的`dom`之类的，之后也会带给你代码提示，但通常不写就行因为有默认值

            - 可选值：

              - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......

            - 示例：
        
              - ```json
                "compilerOptions": {
                    "target": "ES6",
                    "lib": ["ES6", "DOM"],
                    "outDir": "dist",
                    "outFile": "dist/aa.js"
                }
                ```

          - <font color='red'>module</font>

            - 设置编译后代码使用的<font color='gree'>模块化系统</font>

            - 指定使用的模块化规范

            - 可选值：

              - CommonJS、UMD、AMD、System、ES2020、ESNext、None
        
            - 示例：
        
              - ```typescript
                "compilerOptions": {
                    "module": "es2015"
                }
                ```

          - <font color='red'>outDir</font>

            - <font color='gree'>编译后文件的所在目录</font>

            - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置
        
            - 示例：
        
              - ```json
                "compilerOptions": {
                    "outDir": "./dist"
                }
                ```

              - 设置后编译后的js文件将会生成到dist目录

          - <font color='red'>outFile</font>

            - <font color='gree'>将所有的文件编译为一个js文件</font>

            - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中
        
            - <font color='gree'>outFile 配置的时候 module 值只能为amd 和system</font>
        
            - 示例：

              - ```json
                "compilerOptions": {
                    "outFile": "dist/app.js"
                }
                ```

          - <font color='red'>rootDir</font>
        
            - <font color='gree'>指定编译后文件所在的目录</font>
        
            - <font color='gree'>默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</font>

            - 示例：

              - ```json
                "compilerOptions": {
                    "rootDir": "./src"
                }
                ```

          - <font color='red'>allowJs</font>

            - 是否对js文件编译
        
            - 默认是 false
        
            - ```typescript
              "allowJs": false
              ```
        
          - <font color='red'>checkJs</font>
        
            - 是否对 js 文件进行检查（ 按照TS规范对JS文件进行检查）

            - 默认也是 false

            - 示例：
        
              - ```json
                "compilerOptions": {
                    "allowJs": true,
                    "checkJs": true
                }
                ```
        
          - <font color='red'>removeComments</font>
        
            - 编译后是否移除注释
            - 默认值：false
        
          - <font color='red'>noEmit</font>
        
            - <font color='gree'>不生成编译文件，但实际编译检查的过程进行了</font>
            - 默认值：false
        
          - sourceMap
        
            - 是否生成sourceMap
            - 默认值：false
        
            
        
        - 严格检查
        
          - <font color='gree'>strict</font>
            
            - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查
            - 其他的严格检车都不用写了，总开关
          - <font color='red'>alwaysStrict</font>
            
            - 总是以严格模式对代码进行编译
            - 设置编译后的文件为严格模式，默认是false
            - 题外话：js 文件严格模式  ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-11-05_17-09-21.jpg)
            
          - <font color='red'>noImplicitAny</font>
            
            - 禁止隐式的any类型
            - 若设置为 true 则会检测代码中的隐式的any（即未声明的），并报错
            
          - <font color='red'>noImplicitThis</font>
            
            - 禁止类型不明确的this
            
          - strictBindCallApply
            - 严格检查bind、call和apply的参数列表
            
          - strictFunctionTypes
            - 严格检查函数的类型
            
          - <font color='red'>strictNullChecks</font>
            
            - 严格的空值检查     true, false
            
            - 例如：
            
            - ```typescript
              let box1 = document.getElementById('box1');
              box1.addEventListener('click', function (){
                  alert('hello');
              });
              
              // box1指针有可能不存在，那box1就可能为null空值的风险，
              // 当打开 true 时，box1.addEventListener的box1，则会报错
              
              // 解决办法：
              let box1 = document.getElementById('box1');
              	if(box1 !== null){
                      box1.addEventListener('click', function (){
                  		alert('hello');
                  }
              });
                      
              let box1 = document.getElementById('box1');
              box1?.addEventListener('click', function (){
                  alert('hello');
              });
              ```
            
              
            
          - strictPropertyInitialization
            - 严格检查属性是否初始化
        
        - 额外检查
        
          - noFallthroughCasesInSwitch
            - 检查switch语句包含正确的break
          - noImplicitReturns
            - 检查函数没有隐式的返回值
          - noUnusedLocals
            - 检查未使用的局部变量
          - noUnusedParameters
            - 检查未使用的参数
        
        - 高级
        
          - allowUnreachableCode
            - 检查不可达代码
            - 可选值：
              - true，忽略不可达代码
              - false，不可达代码将引起错误
          - <font color='red'>noEmitOnError</font>
            - <font color='gree'>有错误的情况下不进行编译</font>
            - 默认值：false

## 4、webpack

- 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。

- 步骤：

  1. 初始化项目

     - 进入项目根目录，执行命令 ``` npm init -y```
       - 主要作用：创建package.json文件

  2. 下载构建工具

     - ```npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin```
       
       - 共安装了7个包
         - webpack
           - 构建工具webpack
         - webpack-cli
           - webpack的命令行工具
         - webpack-dev-server
           - webpack的开发服务器
         - typescript
           - ts编译器
         - ts-loader
           - ts加载器，用于在webpack中编译ts文件
           
           - ---------------------------------------------------------------------------
         - html-webpack-plugin
           - webpack中html插件，用来自动创建html文件
         - clean-webpack-plugin
           - webpack中的清除插件，每次构建都会先清除目录
  
  3. 根目录下创建webpack的配置文件webpack.config.js
  
     - ```javascript
       const path = require("path");
       // 引入插件
       const HtmlWebpackPlugin = require("html-webpack-plugin");
       const { CleanWebpackPlugin } = require("clean-webpack-plugin");
       
       // webpage 中所有的配置信息都应该写在module.exports中
       module.exports = {
           optimization:{
               minimize: false // 关闭代码压缩，可选
           },
       	
           // 指定入口文件
           entry: "./src/index.ts",
           
           devtool: "inline-source-map",
           
           devServer: {
               contentBase: './dist'
           },
       	
           // 指定打包文件所在目录
           output: {
               // 指定打包文件的目录
               path: path.resolve(__dirname, "dist"),
               // 打包文件的文件名
               filename: "bundle.js",
               environment: {
                   arrowFunction: false // 关闭webpack的箭头函数，可选
               }
           },
       	
       	// 用来设置引用模块
           resolve: {
               extensions: [".ts", ".js"]
           },
           
           // 指定webpage打包时使用的模块
           module: {
               // 指定加载规则
               rules: [
                   {
                       // 规则生效的文件
                       test: /\.ts$/,
                       // 要使用的 loader
                       use: {
                          loader: "ts-loader"     
                       },
                       // 排除的 不生效的文件
                       exclude: /node_modules/
                   }
               ]
           },
       	
           // 配置webpage插件
           plugins: [
               new CleanWebpackPlugin(),
               new HtmlWebpackPlugin({
                   title:'TS测试'  // 自定义的生成index.html的title
               }),
           ]
       
       }
       ```
  
  4. 根目录下创建tsconfig.json，配置可以根据自己需要
  
     - ```json
       {
           "compilerOptions": {
               "target": "ES2015",
               "module": "ES2015",
               "strict": true
           }
       }
       ```

  5. 修改package.json添加如下配置
  
     - ```json
       {
         ...略...
         "scripts": {
           "test": "echo \"Error: no test specified\" && exit 1",
           "build": "webpack",
           "start": "webpack serve --open chrome.exe"
         },
         ...略...
       }
       ```
  
  6. 在src下创建ts文件，并在并命令行执行```npm run build```对代码进行编译，或者执行```npm start```来启动开发服务器
  
     

## 5、Babel

- 经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。

  1. 安装依赖包：
     - ```npm i -D @babel/core @babel/preset-env babel-loader core-js```
     - 共安装了4个包，分别是：
       - @babel/core
         - babel的核心工具
       - @babel/preset-env
         - babel的预定义环境
       - @babel-loader
         - babel在webpack中的加载器
       - core-js
         - core-js用来使老版本的浏览器支持新版ES语法

  2. 修改webpack.config.js配置文件

     - ```javascript
       ...略...
       module: {
           rules: [
               {
                   test: /\.ts$/,
                   use: [
                       {
                           loader: "babel-loader",
                           options:{
                               presets: [
                                   [
                                       "@babel/preset-env",
                                       {
                                           "targets":{
                                               "chrome": "58",
                                               "ie": "11"
                                           },
                                           "corejs":"3",
                                           "useBuiltIns": "usage"
                                       }
                                   ]
                               ]
                           }
                       },
                       {
                           loader: "ts-loader",
       
                       }
                   ],
                   exclude: /node_modules/
               }
           ]
       }
       ...略...
       ```

     - 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。







# 第二章：面向对象

面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，<font color='gree'>简而言之就是程序之中所有的操作都需要通过对象来完成</font>。

- 举例来说：
  - 操作浏览器要使用window对象
  - 操作网页要使用document对象
  - 操作控制台要使用console对象

一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的<font color='gree'>抽象</font>，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。<font color='gree'>程序也是对事物的抽象</font>，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。

在程序中所有的对象都被分成了两个部分<font color='gree'>数据和功能</font>，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。<font color='gree'>数据在对象中被成为属性，而功能就被称为方法</font>。<font color='gree'>所以简而言之，在程序中一切皆是对象</font>。

## 1、类（class）

要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，<font color='gree'>所谓的类可以理解为对象的模型</font>，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。

- 定义类：

  - ```typescript
    class 类名 {
    	属性名: 类型;
    	
        // constructor 被称为构造函数
        // 构造函数会在对象创建时调用
    	constructor(参数: 类型){
            // 在实例方法中，this 就表示当前创建的的实例
            // 在构造函数中当前对象就是当前新建的那个对象
            // 可以通过 this 向新建的对象中添加属性
    		this.属性名 = 参数;
    	}
    	
    	方法名(){
    		....
    	}
    
    }
    
    --------------------------------------
    // 在学习完修饰符后，可以使用另一种写法来简便定义类，不再需要定义属性
    class Person{
        
      // 可以直接将属性定义在构造函数中
      constructor(public name: string, public age: number){
      }
    
      sayHello(){
          console.log(`大家好，我是${this.name}`);
      }
    }
    ```

- 示例：

  - ```typescript
    class Person{
        name: string;
        age: number;
    
        constructor(name: string, age: number){
            this.name = name;
            this.age = age;
        }
    
        // 定义方法
        sayHello(){
            console.log(`大家好，我是${this.name}`);
        }
    }
    
    -----------------------------
    
    class Person{
        name: string = '孙悟空';
        age: number = 18;
    }
    ```

- 使用类：

  - ```typescript
    const p = new Person('孙悟空', 18);
    p.sayHello();
    
    --------------------
    const p = new Person();
    console.log(p.number)
    ```

## 2、面向对象的特点

- 封装

  - <font color='gree'>对象实质上就是属性和方法的容器</font>，它的主要作用就是存储属性和方法，这就是所谓的封装

  - 默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置

  - <font color='gree'>只读属性（readonly）</font>：

    - 如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改

    - ```typescript
      class Person{
          readonly name: string;
          readonly age: number;
      }
      ```

  - <font color='gree'>TS中属性具有三种修饰符</font>：(在属性前)

    - <font color='red'>public（默认值）</font>，公共属性，可以在任意位置访问修改，类、<font color='red'>子类</font>和对象中修改
    - <font color='red'>protected </font>，受包含的属性，只能在当前类、子类内部中进行访问（修改）
    - <font color='red'>private </font>，私有属性，只能在类内部中访问（修改），<font color='gree'>子类内部不行</font>

  - 示例：

    - <font color='red'>public</font>

      - ```typescript
        // 现在属性是在对象设置的。属性可以任意的被修改，属性可以任意被修改将会导致对象中的数据变得非常不安全
        class Person{
            public name: string; // 写或什么都不写都是public
            public age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以在类中修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 可以通过对象修改
        ```

    - <font color='red'>protected</font>

      - ```typescript
        class Person{
            protected name: string;
            protected age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中可以修改
            }
            
            test(){
                console.log(this.name); // 可以访问
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

    - <font color='red'>private</font>

      - ```typescript
        class Person{
            private name: string;
            private age: number;
        
            constructor(name: string, age: number){
                this.name = name; // 可以修改
                this.age = age;
            }
        
            sayHello(){
                console.log(`大家好，我是${this.name}`);
            }
        }
        
        class Employee extends Person{
        
            constructor(name: string, age: number){
                super(name, age);
                this.name = name; //子类中不能修改
            }
        }
        
        const p = new Person('孙悟空', 18);
        p.name = '猪八戒';// 不能修改
        ```

  - <font color='gree'>属性存取器</font>

    - 对于一些不希望被任意修改的属性，可以将其设置为`private`

    - 直接将其设置为`private`将导致<font color='gree'>无法再通过对象修改其中的属性</font>

    - 我们可以<font color='gree'>在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的<font color='red'>存取器</font></font>

    - <font color='gree'>读取属性的方法叫做<font color='red'>`setter`</font>方法，设置属性的方法叫做<font color='red'>`getter`</font>方法</font>

    - 存取器的意义：private实现属性的私有化，存取器实现对属性操作的限制

    - 示例：

      - ```typescript
        class Person{
            private _name: string;
        
            constructor(name: string){
                this._name = name;
            }
        		
            // TS 中设置 getter 方法的方式
            get name(){
                return this._name;
            }
        
            // TS 中设置 setter 方法的方式
            // set 只能有一个参数
            set name(name: string){
                this._name = name;
            }
        
            // 定义方法，用来设置name属性 与上面的方法效果一样，所以还是推荐上面的方法
            // getname(){
            // 		return this._name;
        	// }
            // // 定义方法，用来获取name属性 与上面的方法效果一样，所以还是推荐上面的方法
            // setname(name: string){
            // 		this._name = name;
        	// }
        }
        
        const p1 = new Person('孙悟空');
        console.log(p1.name); // 通过getter读取name属性
        p1.name = '猪八戒'; // 通过setter修改name属性
        
        // console.log(p1.getname());
        // p1.setname('zhubajie');
        ```

  - <font color='gree'>静态属性</font>

    - 静态属性（方法），也称为<font color='gree'>类属性</font>。使用静态属性<font color='gree'>无需创建实例</font>，通过类即可直接使用

    - 静态属性（方法）使用static开头

    - 示例：

      - ```typescript
        class Tools{
            static PI = 3.1415926;
            
            static sum(num1: number, num2: number){
                return num1 + num2
            }
        }
        
        console.log(Tools.PI);
        console.log(Tools.sum(123, 456));
        ```

  - <font color='gree'>this</font>

    - <font color='gree'>在类中，使用this表示当前对象</font>

- <font color='gree'>继承</font>

  - 继承时面向对象中的又一个特性

  - 通过继承可以将其他类中的属性和方法引入到当前类中

    - 示例：

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        }
        
        /*	Dog extends Animal
        *	此时，Animal 被称为父类，Dog被称为子类
        *	使用继承后，子类将会拥有父类所有的方法和属性
        *	通过继承可以将多个类中共有的代码写在一个父类中，
        *		这样只需要写一次即可让所有的子类都同时拥有父类中的属性和方法
        *		如果希望扩展，那在子类内加就行
        *	-如果在子类中添加了子和父类相同的方法，则子类方法会覆盖掉父类的方法
        *	-这种子类覆盖父类方法的形式，我们称为方法重写
        */
        
        // 定义一个表示狗的类
        // 使 Dog 类继承 Animal 类
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

  - <font color='gree'>通过继承可以在不修改类的情况下完成对类的扩展</font>

  - <font color='red'>重写</font>

    - <font color='gree'>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</font>

    - 示例1： 重写<font color='red'>方法</font>的情况

      - ```typescript
        class Animal{
            name: string;
            age: number;
        
            constructor(name: string, age: number){
                this.name = name;
                this.age = age;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        class Dog extends Animal{
        
            bark(){
                console.log(`${this.name}在汪汪叫！`);
            }
        
            run(){
                console.log(`子类中的run方法，会重写父类中的run方法！`);
            }
        }
        
        const dog = new Dog('旺财', 4);
        dog.bark();
        ```

      - 在子类中可以使用super来完成对父类的引用

        > 为什么要用 super()

    - 示例2: <font color='gree'>重写属性的话</font>

      - ```typescript
        // 父
        class Animal{
            name: string;
        
            constructor(name: string){
                this.name = name;
            }
        
            run(){
                console.log(`父类中的run方法！`);
            }
        }
        
        // 子
        
        // 报错，如下图一
        // 原因：子内重写了`constructor`构造函数，故而父内的constructor失效，原有的属性声明失效
        class Dog extends Animal{
        
            age: number;
        
            constructor(name: string, age: number){
                this.age = age;
            }
        }
        
        // 正确调用
        class Dog extends Animal{
        
            age: number;
        
            constructor(name: string, age: number){
                // 同样加上name的属性传参
                surper(name);	// 调用父类的构造函数，且super必须写在其他子类重写代码前
                this.age = age;
            }
        }
        
        
        
        // 调用
        const dog = new Dog('旺财', 4);
        ```

        ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-11-10_15-51-16.jpg)

        ```
        
        ```

        

  - <font color='gree'>抽象类（abstract class）</font>

    - 抽象类是<font color='gree'>专门用来被其他类所继承的类</font>，它只能被其他类所继承<font color='gree'>不能用来创建实例</font>

    - ```typescript
      /*
      *	以abstract开头的类是抽象类，
      *		抽象类和其他类区别不大，只是不能用来创建对象
      *		抽象类就是专门用来被继承的类
      * */
      abstract class Animal{
          // 定义一个抽象方法
          // 抽象方法使用 abstract 开头，没有方法体
          // 抽象方法只能放在抽象类中，子类必须对抽象方法进行重写
          abstract run(): void;
          // 公用方法 bark()
          bark(){
              console.log('动物在叫~');
          }
      }
      
      class Dog extends Animals{
          // 重写 run()
          run(){
              console.log('狗在跑~');
          }
      }
      ```

    - <font color='gree'>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</font>

    

## 3、接口（Interface）

接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。

> <font color='gree'>相当于 抽象类是半抽象的，不一定有抽象方法属性。接口是完全抽象的，方法和属性必须是抽象的</font>
>
> <font color='gree'>接口可以看作是一种规范</font>

- 示例（检查对象类型）：

  - ```typescript
    interface Person{
        name: string;
        sayHello():void;
    }
    
    function fn(per: Person){
        per.sayHello();
    }
    
    fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});
    
    ```

- 示例（实现）

  - ```typescript
    /*
    *	接口可以在定义类的时候限制类的结构
    *		接口中所有的属性都不能有实际的值
    *		接口只定义对象的结构，而不考虑值
    *		在接口中所有的方法都是抽象方法
    */
    interface Person{
        name: string;
        sayHello():void;
    }
    
    /*
    *	定义类时候，可以使类去实现接口
    *		实现接口就是满足接口的规范
    */
    class Student implements Person{
        constructor(public name: string) {
        }
    
        sayHello() {
            console.log('大家好，我是'+this.name);
        }
    }
    ```

- 示例:<font color='gree'>当成类型使用</font>（创造对象）

  - ```typescript
    /*
    *	接口用来定义一个类的结构，用来定义一个类中应该包含哪些属性和方法
    *		同时也可以当成 类型声明去使用
    */
    interface myType{
        name: string;
        age: number;
    }
    
    // 建立一个实例对象
    const obj: myType = {
        name: 'sss',
        age: 19,
    }
    
    ```

    ```typescript
    /*
    *	与类型对象 type 不同，同一个接口可以反复声明
    *		声明同一个接口，他们的属性会叠加
    */
    interface myType{
        name: string;
        age: number;
    }
    
    interface myType{
        gender: string;
    }
    
    // 建立一个实例对象
    const obj: myType = {
        name: 'sss',
        age: 19,
        gender: 'adcad'
    }
    
    ```

    ![](C:\Users\shizeyu\Desktop\notes\Ajax-vue\Snipaste_2023-11-11_14-53-06.jpg)

- 接口中的继承

- ```typescript
  interface Ponit2d{
  	x: number;
      y: number;
  }
  
  interface Ponit3d extends Ponit2d {
      z: number;
  }
  
  // 继承后，Point3D 就有了 Point2D 的所有属性和方法（此时，Point3D 同时有 x、y、z 三个属性）
  ```

  


## 4、泛型（Generic）

定义一个<font color='greree'>函数或类</font>时，有些情况下无法确定其中要使用的<font color='gree'>具体类型（返回值、参数、属性的类型不能确定）</font>，此时泛型便能够发挥作用。

> <font color='greree'>泛型是把类型也作为参数传递，这样在定义时可以把类型也动态化</font>

- 举个例子：

  - ```typescript
    function test(arg: any): any{
    	return arg;
    }
    ```

  - 上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先<font color='greree'>使用any会关闭TS的类型检查</font>，其次这样设置也不能体现出参数和返回值是相同的类型

  

  - 使用泛型：

  - ```typescript
    function test<T>(arg: T): T{
    	return arg;
    }
    ```

  - <font color='gree'>这里的```<T>```就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型</font>。

  - 那么如何使用上边的函数呢？

    - <font color='red'>方式一</font>（直接使用）：

      - ```typescript
        test(10)
        ```

      - 使用时可以直接传递参数使用，<font color='greree'>类型会由TS自动推断出来，也就相当于给泛型传递了类型</font>，但有时编译器无法自动推断时还需要使用下面的方式

    - <font color='red'>方式二</font>（指定类型）：

      - ```typescript
        test<number>(10)
        ```

      - 也可以在函数后手动指定泛型

  - 可以同时指定多个泛型，泛型间使用逗号隔开：

    - ```typescript
      function test<T, K>(a: T, b: K): K{
          return b;
      }
      
      test<number, string>(10, "hello");
      ```

    - <font color='gree'>使用泛型时，完全可以将泛型当成是一个普通的类去使用</font>

  - <font color='red'>类</font>中同样可以使用泛型：

    - ```typescript
      class MyClass<T>{
          prop: T;
      
          constructor(prop: T){
              this.prop = prop;
          }
      }
      
      const mc = new MyClass<string>('abbb')
      ```

  - 除此之外，也可以对泛型的范围进行约束

    - ```typescript
      interface MyInter{
          length: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length;
      }
      
      // 传过去的值要要符合规范，传过去的值都会视为对象
      test({length: 10,});
      test('100');   // 在这里 字符串100是可以的，因为 字符串 和 数组默认自带 length这个属性，恰好名字相同
      
      
      ----------------------------------
      interface MyInter1{
          length1: number;
      }
      
      function test<T extends MyInter>(arg: T): number{
          return arg.length1;
      }
      
      test('100');   // 报错了，因为没有 length1 属性
      ```

    - <font color='gree'>使用`T extends MyInter`表示泛型`T`必须是`MyInter`的`子类`，不一定非要使用<font color='greree'>接口类</font>和<font color='greree'>抽象类</font>同样适用</font>。

    - 





